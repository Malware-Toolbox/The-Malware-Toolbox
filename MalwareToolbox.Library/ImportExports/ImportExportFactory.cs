using MalwareToolbox.Library.ImportExports.RegShot;
using MalwareToolbox.Library.ImportExports.Strings;
using MalwareToolbox.LibraryC.RegShot;

namespace MalwareToolbox.Library.ImportExports;

public class ImportExportFactory<T>
{
    public static ImportExportFactory<Dictionary<string, List<string>>> ForStrings()
    {
        var factory = new ImportExportFactory<Dictionary<string, List<string>>>();
        factory.RegisterHandler(new StringsJsonHandler());
        factory.RegisterHandler(new StringsTextHandler());
        return factory;
    }

    public static ImportExportFactory<RegistrySnapshot> ForRegistry()
    {
        var factory = new ImportExportFactory<RegistrySnapshot>();
        factory.RegisterHandler(new RegistryHandler());
        return factory;
    }

    private readonly Dictionary<string, IImportExportHandler<T>> _handlers;

    protected ImportExportFactory()
    {
        _handlers = new Dictionary<string, IImportExportHandler<T>>();
    }

    public void RegisterHandler(IImportExportHandler<T> handler)
    {
        _handlers.Add(handler.FileType, handler);
    }

    public IImportExportHandler<T> GetHandler(string fileType)
    {
        return _handlers[fileType];
    }

    public async Task<T?> ImportAsync(string filePath)
    {
        var handler = GetHandler(Path.GetExtension(filePath));
        using var stream = File.OpenText(filePath);
        return await Task.Run(async () => await handler.Import(filePath, stream));
    }

    public async Task<bool> ExportAsync(string filePath, T data)
    {
        var handler = GetHandler(Path.GetExtension(filePath));
        await using var stream = File.CreateText(filePath);
        return await Task.Run(async () => await handler.Export(filePath, stream, data));
    }
}
