using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Controls.Primitives;
using Microsoft.UI.Xaml.Data;
using Microsoft.UI.Xaml.Input;
using Microsoft.UI.Xaml.Media;
using Microsoft.UI.Xaml.Navigation;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Foundation;
using Windows.Foundation.Collections;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace MalwareToolbox.DesktopApp.Tools
{
    /// <summary>
    /// An empty page that can be used on its own or navigated to within a Frame.
    /// </summary>
    public sealed partial class FileInfo : Page
    {
        public FileInfo()
        {
            this.InitializeComponent();
        }
        protected override void OnNavigatedTo(NavigationEventArgs e)
        {
            var fileManager = (Application.Current as App)!.MainWindow.FileManager;

            // Get file for PE Info
            var pe = new PE(fileManager.WinFile);

            // File Properties
            var filePropertiesPath = pe.File.Path;
            var filePropertiesSize = pe.File.Size;
            var filePropertiesDLL = pe.IsDLL();
            var fileProperties64Bit = pe.Is64Bit();

            // Dos Headers
            var dosHeadersMagic = pe.DosHeaders.Magic;
            var dosHeadersLfanew = pe.DosHeaders.Lfanew;

            // Hashes
            var md5Hash = new Md5Hasher(fileManager.WinFile);
            var sha256Hash = new Sha256Hasher(fileManager.WinFile);

            // NT File Headers
            var fileSignature = pe.NtFileHeaders.Signature;
            var fileMachine = pe.NtFileHeaders.Machine;
            var fileSections = pe.NtFileHeaders.NumberOfSections;
            var fileTimeDateStamp = pe.NtFileHeaders.TimeDateStamp;
            var filePointerToSymbol = pe.NtFileHeaders.PointerToSymbolTable;
            var fileSymbols = pe.NtFileHeaders.NumberOfSymbols;
            var fileOptionalHeader = pe.NtFileHeaders.SizeOfOptionalHeader;
            var fileCharacteristics = pe.NtFileHeaders.Characteristics;

            // NT Optional Headers
            var fileMagic = pe.NtOptionalHeaders.Magic;
            var majorLinkerVersion = pe.NtOptionalHeaders.MajorLinkerVersion;
            var minorLinkerVersion = pe.NtOptionalHeaders.MinorLinkerVersion;
            var sizeOfCode = pe.NtOptionalHeaders.SizeOfCode;
            var sizeOfInitializedData = pe.NtOptionalHeaders.SizeOfInitializedData;
            var sizeOfUninitializedData = pe.NtOptionalHeaders.SizeOfUninitializedData;
            var addressOfEntryPoint = pe.NtOptionalHeaders.AddressOfEntryPoint;
            var baseOfCode = pe.NtOptionalHeaders.BaseOfCode;
            var sectionAlignment = pe.NtOptionalHeaders.SectionAlignment;
            var fileAlignment = pe.NtOptionalHeaders.FileAlignment;
            var majorOperatingSystemVersion = pe.NtOptionalHeaders.MajorOperatingSystemVersion;
            var minorOperatingSystemVersion = pe.NtOptionalHeaders.MinorOperatingSystemVersion;
            var majorImageVersion = pe.NtOptionalHeaders.MajorImageVersion;
            var minorImageVersion = pe.NtOptionalHeaders.MinorImageVersion;
            var majorSubsystemVersion = pe.NtOptionalHeaders.MajorSubsystemVersion;
            var minorSubsystemVersion = pe.NtOptionalHeaders.MinorSubsystemVersion;
            var win32VersionValue = pe.NtOptionalHeaders.Win32VersionValue;
            var sizeOfImage = pe.NtOptionalHeaders.SizeOfImage;
            var sizeOfHeaders = pe.NtOptionalHeaders.SizeOfHeaders;
            var checkSum = pe.NtOptionalHeaders.CheckSum;
            var subSystem = pe.NtOptionalHeaders.Subsystem;
            var dllCharacteristics = pe.NtOptionalHeaders.DllCharacteristics;
            var loaderFlags = pe.NtOptionalHeaders.LoaderFlags;
            var numberOfRvaAndSizes = pe.NtOptionalHeaders.NumberOfRvaAndSizes;
            if (pe.Is64Bit())
            {
                NtOptionalHeader64 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader64)!;
                var imageBase = ntOptionalHeaders.ImageBase;
                var sizeOfStackReserve = ntOptionalHeaders.SizeOfStackReserve;
                var sizeOfStackCommit = ntOptionalHeaders.SizeOfStackCommit;
                var sizeOfHeapReserve = ntOptionalHeaders.SizeOfHeapReserve;
                var sizeOfHeapCommit = ntOptionalHeaders.SizeOfHeapCommit;
            }
            else
            {
                NtOptionalHeader32 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader32)!;
                var baseOfData = ntOptionalHeaders.BaseOfData;
                var imageBase = ntOptionalHeaders.ImageBase;
                var sizeOfStackReserve = ntOptionalHeaders.SizeOfStackReserve;
                var sizeOfStackCommit = ntOptionalHeaders.SizeOfStackCommit;
                var sizeOfHeapReserve = ntOptionalHeaders.SizeOfHeapReserve;
                var sizeOfHeapCommit = ntOptionalHeaders.SizeOfHeapCommit;
            }
            foreach (var section in pe.SectionHeaders)
            {
                var sectionName = section.Name;
                var virtualSize = section.VirtualSize;
                var virtualAddress = section.VirtualAddress;
                var sizeOfRawData = section.SizeOfRawData;
                var pointertoRawData = section.PointerToRawData;
            }

            // Import Table
            foreach (var import in pe.DllImports)
            {
                var importCharacteristics = import.Characteristics;
                var importOriginalFirstThunk = import.OriginalFirstThunk;
                var importTimeDateStamp = import.TimeDateStamp;
                var importForwarderChain = import.ForwarderChain;
                var importname = import.Name;
                var importFirstThunk = import.FirstThunk;
                var importFunctions = import.Functions;
                foreach (var func in import.Functions)
                {
                    var functionName = func.Name;
                }
            }
        }
    }
}
