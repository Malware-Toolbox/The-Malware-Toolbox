using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using CommunityToolkit.Mvvm.ComponentModel;
using MalwareToolbox.DesktopApp.Core.Configurations;

namespace MalwareToolbox.DesktopApp.Core.Utils;

public class ToolboxObservableRecipient : ObservableRecipient
{
    protected readonly ThreadHelper ThreadHelper;
    protected readonly IConfigProvider ConfigProvider;

    public ToolboxObservableRecipient()
    {
        ThreadHelper = App.Instance.ThreadHelper;
        ConfigProvider = App.Instance.ConfigProvider;
    }

    /// <summary>
    /// Compares the current and new values for a given property. If the value has changed,
    /// raises the <see cref="PropertyChanging"/> event, updates the property with the new
    /// value, then raises the <see cref="PropertyChanged"/> event.
    /// </summary>
    /// <typeparam name="T">The type of the property that changed.</typeparam>
    /// <param name="field">The field storing the property's value.</param>
    /// <param name="newValue">The property's value after the change occurred.</param>
    /// <param name="propertyName">(optional) The name of the property that changed.</param>
    /// <returns><see langword="true"/> if the property was changed, <see langword="false"/> otherwise.</returns>
    /// <remarks>
    /// The <see cref="PropertyChanging"/> and <see cref="PropertyChanged"/> events are not raised
    /// if the current and new value for the target property are the same.
    /// </remarks>
    protected bool SetPropertyUIThread<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string? propertyName = null)
    {
        // We duplicate the code here instead of calling the overload because we can't
        // guarantee that the invoked SetProperty<T> will be inlined, and we need the JIT
        // to be able to see the full EqualityComparer<T>.Default.Equals call, so that
        // it'll use the intrinsics version of it and just replace the whole invocation
        // with a direct comparison when possible (eg. for primitive numeric types).
        // This is the fastest SetProperty<T> overload so we particularly care about
        // the codegen quality here, and the code is small and simple enough so that
        // duplicating it still doesn't make the whole class harder to maintain.
        if (EqualityComparer<T>.Default.Equals(field, newValue))
        {
            return false;
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() =>
        {
            OnPropertyChanging(propertyName);
        });
        
        field = newValue;

        ThreadHelper.DispatcherQueue.TryEnqueue(() =>
        {
            OnPropertyChanged(propertyName);
        });

        return true;
    }

    protected bool SetProperty<T>(Config<T> config, T newValue, [CallerMemberName] string propertyName = null)
    {
        // We duplicate the code here instead of calling the overload because we can't
        // guarantee that the invoked SetProperty<T> will be inlined, and we need the JIT
        // to be able to see the full EqualityComparer<T>.Default.Equals call, so that
        // it'll use the intrinsics version of it and just replace the whole invocation
        // with a direct comparison when possible (eg. for primitive numeric types).
        // This is the fastest SetProperty<T> overload so we particularly care about
        // the codegen quality here, and the code is small and simple enough so that
        // duplicating it still doesn't make the whole class harder to maintain.

        if (EqualityComparer<T>.Default.Equals(ConfigProvider.GetConfig(config), newValue))
        {
            return false;
        }

        OnPropertyChanging(propertyName);

        ConfigProvider.SetConfig(config, newValue);

        OnPropertyChanged(propertyName);

        return true;
    }
}
