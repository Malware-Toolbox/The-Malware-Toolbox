using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.UI;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Navigation;

// To learn more about WinUI, the WinUI project structure,
// and more about our project templates, see: http://aka.ms/winui-project-info.

namespace MalwareToolbox.DesktopApp.Views.Tools;

/// <summary>
/// An empty page that can be used on its own or navigated to within a Frame.
/// </summary>
public sealed partial class FileInfo : Page, IPageRequireFile
{
    private ObservableCollection<GroupedList> sectionListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> importsListCollection = new ObservableCollection<GroupedList>();

    public FileInfo()
    {
        this.InitializeComponent();
    }
    protected override void OnNavigatedTo(NavigationEventArgs e)
    {
        var fileManager = App.Instance.WinFileManager;

        // Get file for PE Info
        var pe = new PE(fileManager.WinFile);
        if (!pe.LoadHeaders())
        {
            Console.WriteLine("Failed to load PE");
            return;
        }



        // File Properties
        // var filePropertiesPath = pe.File.Path;
        filePropertiesPathText.Text = "Path: " + pe.File.Path;
        filePropertiesSizeText.Text = "Size: " + Convert.ToString(pe.File.Size);
        filePropertiesDLLText.Text = "Is DLL: " + Convert.ToString(pe.IsDLL());
        fileProperties64BitText.Text = "Is 64 bit: " + Convert.ToString(pe.Is64Bit());

        // Dos Headers
        dosHeadersMagicText.Text = "Magic: " + Convert.ToString(pe.DosHeaders.Magic);
        dosHeadersLfanewText.Text = "Lfanew: " + Convert.ToString(pe.DosHeaders.Lfanew);

        // Hashes
        var md5Hash = new Md5Hasher(fileManager.WinFile);
        md5HashText.Text = "MD5: " + Convert.ToHexString(md5Hash.Hash());
        var sha256Hash = new Sha256Hasher(fileManager.WinFile);
        sha256HashText.Text = "SHA256: " + Convert.ToHexString(sha256Hash.Hash());

        // NT File Headers
        fileSignatureText.Text = "Signature: " + Convert.ToString(pe.NtFileHeaders.Signature);
        fileMachineText.Text = "Machine: " + Convert.ToString(pe.NtFileHeaders.Machine);
        fileSectionsText.Text = "NumberOfSections: " + Convert.ToString(pe.NtFileHeaders.NumberOfSections);
        fileTimeDateStampText.Text = "TimeDateStamp: " + Convert.ToString(pe.NtFileHeaders.TimeDateStamp);
        filePointerToSymbolText.Text = "PointerToSymbolTable: " + Convert.ToString(pe.NtFileHeaders.PointerToSymbolTable);
        fileSymbolsText.Text = "NumberOfSymbols: " + Convert.ToString(pe.NtFileHeaders.NumberOfSymbols);
        fileOptionalHeaderText.Text = "SizeOfOptionalHeader: " + Convert.ToString(pe.NtFileHeaders.SizeOfOptionalHeader);
        fileCharacteristicsText.Text = "Characteristics: " + Convert.ToString(pe.NtFileHeaders.Characteristics);

        // NT Optional Headers
        fileMagicText.Text = "Magic: " + Convert.ToString(pe.NtOptionalHeaders.Magic);
        majorLinkerVersionText.Text = "MajorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorLinkerVersion);
        minorLinkerVersionText.Text = "MinorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorLinkerVersion);
        sizeOfCodeText.Text = "SizeOfCode: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfCode);
        sizeOfInitializedDataText.Text = "SizeOfInitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfInitializedData);
        sizeOfUninitializedDataText.Text = "SizeOfUninitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfUninitializedData);
        addressOfEntryPointText.Text = "AddressOfEntryPoint: " + Convert.ToString(pe.NtOptionalHeaders.AddressOfEntryPoint);
        baseOfCodeText.Text = "BaseOfCode: " + Convert.ToString(pe.NtOptionalHeaders.BaseOfCode);
        sectionAlignmentText.Text = "SectionAlignment: " + Convert.ToString(pe.NtOptionalHeaders.SectionAlignment);
        fileAlignmentText.Text = "FileAlignment: " + Convert.ToString(pe.NtOptionalHeaders.FileAlignment);
        majorOperatingSystemVersionText.Text = "MajorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorOperatingSystemVersion);
        minorOperatingSystemVersionText.Text = "MinorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorOperatingSystemVersion);
        majorImageVersionText.Text = "MajorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorImageVersion);
        minorImageVersionText.Text = "MinorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorImageVersion);
        majorSubsystemVersionText.Text = "MajorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorSubsystemVersion);
        minorSubsystemVersionText.Text = "MinorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorSubsystemVersion);
        win32VersionValueText.Text = "Win32VersionValue: " + Convert.ToString(pe.NtOptionalHeaders.Win32VersionValue);
        sizeOfImageText.Text = "SizeOfImage: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfImage);
        sizeOfHeadersText.Text = "SizeOfHeaders: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfHeaders);
        checkSumText.Text = "CheckSum: " + Convert.ToString(pe.NtOptionalHeaders.CheckSum);
        subSystemText.Text = "Subsystem: " + Convert.ToString(pe.NtOptionalHeaders.Subsystem);
        dllCharacteristicsText.Text = "DllCharacteristics: " + Convert.ToString(pe.NtOptionalHeaders.DllCharacteristics);
        loaderFlagsText.Text = "LoaderFlags: " + Convert.ToString(pe.NtOptionalHeaders.LoaderFlags);
        numberOfRvaAndSizesText.Text = "NumberOfRvaAndSizes: " + Convert.ToString(pe.NtOptionalHeaders.NumberOfRvaAndSizes);


        if (pe.Is64Bit())

        {
            NtOptionalHeader64 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader64)!;
            var imageBase = ntOptionalHeaders.ImageBase;
            imageBaseText.Text = "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase);
            sizeOfStackReserveText.Text = "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve);
            sizeOfStackCommitText.Text = "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit);
            sizeOfHeapReserveText.Text = "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve);
            sizeOfHeapCommitText.Text = "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit);
        }
        else
        {
            NtOptionalHeader32 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader32)!;
            imageBaseText.Text = "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase);
            sizeOfStackReserveText.Text = "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve);
            sizeOfStackCommitText.Text = "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit);
            sizeOfHeapReserveText.Text = "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve);
            sizeOfHeapCommitText.Text = "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit);
        }
      
        foreach (var section in pe.SectionHeaders)
        {
            var SectionHeaderList = new GroupedList(new List<string> { "Virtual Size: " + section.VirtualSize, "Virtual Address: " + section.VirtualAddress, "Size Of Raw Data: " + section.SizeOfRawData, "Pointer to Raw Data: " + section.PointerToRawData });
            SectionHeaderList.Key = section.Name;
         
            sectionListCollection.Add(SectionHeaderList);
        }

        // Import Table
        foreach (var import in pe.DllImports)
        {
           
            var ImportsList = new GroupedList(new List<string>
            {
                "Characteristics: " + import.Characteristics,
                "Original First Thunk: " + import.OriginalFirstThunk,
                "Time Date Stamp: " + import.TimeDateStamp,
                "Forwarder Chain: " + import.ForwarderChain,
                "Name: " + import.Name,
                "First Thunk: " + import.FirstThunk
            });


            foreach (var func in import.Functions)
            {
                var FunctionsList = new GroupedList(new List<string>
                {
                    func.Name
                });
            }
        }
    }
}
