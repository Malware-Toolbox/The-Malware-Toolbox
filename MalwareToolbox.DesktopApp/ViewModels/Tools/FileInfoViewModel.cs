using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Windows.Storage.Pickers;
using CommunityToolkit.WinUI;
using CommunityToolkit.WinUI.UI;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.DesktopApp.UI.Notifications;
using MalwareToolbox.Library.ImportExports;
using MalwareToolbox.Library.Utils;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using MalwareToolbox.LibraryC.Utils;
using Microsoft.UI.Xaml.Controls;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class FileInfoViewModel : ToolboxViewModel
{
    public readonly AdvancedCollectionView SearchSuggestions = new()
    {
        "Path",
        "FileSize",
        "CreationTime",
        "LastAccessTime",
        "LastWriteTime",
        "Is DLL",
        "Is 64 bit",
        "MD5",
        "SHA256",
        "E_Magic",
        "E_Lfanew",
        "Size",
        "DansOffset",
        "EntryNo",
        "DecryptionKey",
        "BuildID",
        "ProductID",
        "Product Count",
        "Machine",
        "Signature",
        "NT File Header",
        "Machine",
        "NumberOfSections",
        "TimeDateStamp",
        "PointerToSymbolTable",
        "NumberOfSymbols",
        "SizeOfOptionalHeader",
        "Characteristics",
        "NT Optional Header",
        "Magic",
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "Win32VersionValue",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem",
        "DllCharacteristics",
        "LoaderFlags",
        "NumberOfRvaAndSizes",
        "NT Optional Header 32",
        "NT Optional Header 64",
        "ImageBase",
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "Virtual Size",
        "Virtual Address",
        "Size Of Raw Data",
        "Pointer to Raw Data",

    };

    private readonly ImportExportFactory<object> _factory;
    private bool _initialised;
    private bool _validPE;
    private string _search;
    private ObservableCollection<AdvancedGroupList> _sectionListCollection;
    private ObservableCollection<AdvancedGroupList> _importsListCollection;
    private ObservableCollection<AdvancedGroupList> _functionsListCollection;
    private ObservableCollection<AdvancedGroupList> _propertiesListCollection;
    private ObservableCollection<AdvancedGroupList> _headersListCollection;
    private ObservableCollection<AdvancedGroupList> _hashesListCollection;
    private ObservableCollection<AdvancedGroupList> _ntHeadersListCollection;
    private ObservableCollection<AdvancedGroupList> _richHeadersCollection;

    public bool ValidPE
    {
        get => _validPE;
        set => SetProperty(ref _validPE, value);
    }

    public ObservableCollection<AdvancedGroupList> SectionListCollection
    {
        get => _sectionListCollection;
        set => SetProperty(ref _sectionListCollection, value);
    }
    
    public ObservableCollection<AdvancedGroupList> PropertiesListCollection
    {
        get => _propertiesListCollection;
        set => SetProperty(ref _propertiesListCollection, value);
    }
    
    public ObservableCollection<AdvancedGroupList> ImportListCollection
    {
        get => _importsListCollection;
        set => SetProperty(ref _importsListCollection, value);
    }
    
    public ObservableCollection<AdvancedGroupList> FunctionsListCollection
    {
        get => _functionsListCollection;
        set => SetProperty(ref _functionsListCollection, value);
    }
    
    public ObservableCollection<AdvancedGroupList> HeadersListCollection
    {
        get => _headersListCollection;
        set => SetProperty(ref _headersListCollection, value);
    }
    
    public ObservableCollection<AdvancedGroupList> HashesListCollection
    {
        get => _hashesListCollection;
        set => SetProperty(ref _hashesListCollection, value);
    }
    
    public ObservableCollection<AdvancedGroupList> NTHeadersListCollection
    {
        get => _ntHeadersListCollection;
        set => SetProperty(ref _ntHeadersListCollection, value);
    }

    public ObservableCollection<AdvancedGroupList> RichHeadersListCollection
    {
        get => _richHeadersCollection;
        set => SetProperty(ref _richHeadersCollection, value);
    }

    public string Search
    {
        get => _search;
        set => SetProperty(_search, value, OnSearchChanged);
    }

    public FileInfoViewModel()
    {
        _factory = ImportExportFactory<object>.SimpleFactory();
        FileManager.WinFileClosed += WinFileManager_WinFileClosed;
    }

    public async void InitFileInfo()
    {
        if (!_initialised && FileManager.IsFileOpened)
        {
            //await Task.Run(LoadFileDetails);
            LoadFileDetails();
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public void LoadFileDetails()
    {
        if (_initialised) return;

        // File Properties
        var propertiesListCollection = new ObservableCollection<AdvancedGroupList>();
        var PropertiesList = new AdvancedGroupList(new ObservableCollection<string>
        {
            "Path: " + FileManager.WinFile.Path,
        });

        var fileProps = FileManager.GetWrapper<WinFileProps>();
        if (fileProps != null)
        {
            PropertiesList.Add("FileSize: " + ToolboxConverters.SizeToString(fileProps.FileSize));
            PropertiesList.Add("CreationTime: " + fileProps.CreationTime.ToString());
            PropertiesList.Add("LastAccessTime: " + fileProps.LastAccessTime.ToString());
            PropertiesList.Add("LastWriteTime: " + fileProps.LastWriteTime.ToString());
        }

        propertiesListCollection.Add(PropertiesList);

        // Hashes
        var md5Hash = new Md5Hasher(FileManager.WinFile);
        var sha256Hash = new Sha256Hasher(FileManager.WinFile);

        var hashesListCollection = new ObservableCollection<AdvancedGroupList>();
        var HashesList = new AdvancedGroupList(new ObservableCollection<string>
        {
            "MD5: " + Convert.ToHexString(md5Hash.Hash()),
            "SHA256: " + Convert.ToHexString(sha256Hash.Hash())
        });
        hashesListCollection.Add(HashesList);
        ThreadHelper.DispatcherQueue.TryEnqueue(() => HashesListCollection = hashesListCollection);

        // Get file for PE Info
        var pe = new PE(FileManager.WinFile);
        if (!pe.LoadHeaders())
        {
            ThreadHelper.DispatcherQueue.TryEnqueue(() =>
            {
                PropertiesListCollection = propertiesListCollection;
                ValidPE = false;
            });
            return;
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() => ValidPE = true);

        // Basic PE info
        PropertiesList.Add("Is DLL: " + Convert.ToString(pe.IsDLL()));
        PropertiesList.Add("Is 64 bit: " + Convert.ToString(pe.Is64Bit()));
        ThreadHelper.DispatcherQueue.TryEnqueue(() => PropertiesListCollection = propertiesListCollection);

        // Dos Headers
        var headersListCollection = new ObservableCollection<AdvancedGroupList>();
        var HeadersList = new AdvancedGroupList(new ObservableCollection<string>
        {
            "E_Magic: " + pe.DosHeaders.Magic,
            "E_Lfanew: " + pe.DosHeaders.Lfanew
        });
        headersListCollection.Add(HeadersList);
        ThreadHelper.DispatcherQueue.TryEnqueue(() => HeadersListCollection = headersListCollection);

        // Rich Headers
        var richHeadersListCollection = new ObservableCollection<AdvancedGroupList>();

        var RichHeadersList = new AdvancedGroupList(new ObservableCollection<string>
        {
            "Size: " + Convert.ToString(pe.richheaders.size),
            "DansOffset: " + Convert.ToString(pe.richheaders.DansOffset),
            "EntryNo: " + Convert.ToString(pe.richheaders.entryno),
            "DecryptionKey: " + Convert.ToString(pe.richheaders.DecryptionKey)
        });
        RichHeadersList.Key = "Details";
        richHeadersListCollection.Add(RichHeadersList);


        foreach (var entry in pe.richheaders.entries)
        {
            var RichHeadersEntriesList = new AdvancedGroupList(new ObservableCollection<string>
            {
                "BuildID: " + entry.BUILDID,
                "ProductID: " +entry.PROID,
                "Product Count: " + entry.count});
            RichHeadersEntriesList.Key = "Entry";
            richHeadersListCollection.Add(RichHeadersEntriesList);
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() => RichHeadersListCollection = richHeadersListCollection);


        // NT Headers
        var ntHeadersListCollection = new ObservableCollection<AdvancedGroupList>();
        var NTHeadersList = new AdvancedGroupList(new ObservableCollection<string>
        {
            Convert.ToString(pe.NtFileHeaders.Signature),
        });
        NTHeadersList.Key = "Signature";
        ntHeadersListCollection.Add(NTHeadersList);

        var NTFileHeadersList = new AdvancedGroupList(new ObservableCollection<string>
        {
            "Machine: " + Convert.ToString(pe.NtFileHeaders.Machine),
            "NumberOfSections: " + Convert.ToString(pe.NtFileHeaders.NumberOfSections),
            "TimeDateStamp: " + Convert.ToString(pe.NtFileHeaders.TimeDateStamp),
            "PointerToSymbolTable: " + Convert.ToString(pe.NtFileHeaders.PointerToSymbolTable),
            "NumberOfSymbols: " + Convert.ToString(pe.NtFileHeaders.NumberOfSymbols),
            "SizeOfOptionalHeader: " + Convert.ToString(pe.NtFileHeaders.SizeOfOptionalHeader),
            "Characteristics: " + Convert.ToString(pe.NtFileHeaders.Characteristics)
        });
        NTFileHeadersList.Key = "NT File Header";
        ntHeadersListCollection.Add(NTFileHeadersList);
        ThreadHelper.DispatcherQueue.TryEnqueue(() => NTHeadersListCollection = ntHeadersListCollection);

        // NT Optional Headers
        var NTOptionalList = new AdvancedGroupList(new ObservableCollection<string>
        {
            "Magic: " + Convert.ToString(pe.NtOptionalHeaders.Magic),
            "MajorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorLinkerVersion),
            "MinorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorLinkerVersion),
            "SizeOfCode: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfCode),
            "SizeOfInitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfInitializedData),
            "SizeOfUninitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfUninitializedData),
            "AddressOfEntryPoint: " + Convert.ToString(pe.NtOptionalHeaders.AddressOfEntryPoint),
            "BaseOfCode: " + Convert.ToString(pe.NtOptionalHeaders.BaseOfCode),
            "SectionAlignment: " + Convert.ToString(pe.NtOptionalHeaders.SectionAlignment),
            "FileAlignment: " + Convert.ToString(pe.NtOptionalHeaders.FileAlignment),
            "MajorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorOperatingSystemVersion),
            "MinorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorOperatingSystemVersion),
            "MajorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorImageVersion),
            "MinorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorImageVersion),
            "MajorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorSubsystemVersion),
            "MinorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorSubsystemVersion),
            "Win32VersionValue: " + Convert.ToString(pe.NtOptionalHeaders.Win32VersionValue),
            "SizeOfImage: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfImage),
            "SizeOfHeaders: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfHeaders),
            "CheckSum: " + Convert.ToString(pe.NtOptionalHeaders.CheckSum),
            "Subsystem: " + Convert.ToString(pe.NtOptionalHeaders.Subsystem),
            "DllCharacteristics: " + Convert.ToString(pe.NtOptionalHeaders.DllCharacteristics),
            "LoaderFlags: " + Convert.ToString(pe.NtOptionalHeaders.LoaderFlags),
            "NumberOfRvaAndSizes: " + Convert.ToString(pe.NtOptionalHeaders.NumberOfRvaAndSizes)
        });
        NTOptionalList.Key = "NT Optional Header";
        ntHeadersListCollection.Add(NTOptionalList);

        if (pe.Is64Bit())

        {
            NtOptionalHeader64 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader64)!;
            var NTOptionalList64 = new AdvancedGroupList(new ObservableCollection<string>
            {
            "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase),
            "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve),
            "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit),
            "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve),
            "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit),
            });
            NTOptionalList64.Key = "NT Optional Header 64";
            ntHeadersListCollection.Add(NTOptionalList64);
        }
        else
        {
            NtOptionalHeader32 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader32)!;
            var NTOptionalList32 = new AdvancedGroupList(new ObservableCollection<string>
            {
                "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase),
                "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve),
                "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit),
                "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve),
                "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit),
            });
            NTOptionalList32.Key = "NT Optional Header 32";
            ntHeadersListCollection.Add(NTOptionalList32);
        }

        // Sections
        var sectionListCollection = new ObservableCollection<AdvancedGroupList>();
        foreach (var section in pe.SectionHeaders)
        {
            var SectionHeaderList = new AdvancedGroupList(new ObservableCollection<string>
            {
                "Virtual Size: " + section.VirtualSize,
                "Virtual Address: " + section.VirtualAddress, 
                "Size Of Raw Data: " + section.SizeOfRawData,
                "Pointer to Raw Data: " + section.PointerToRawData
            });
            SectionHeaderList.Key = section.Name;
            sectionListCollection.Add(SectionHeaderList);
        }
        ThreadHelper.DispatcherQueue.TryEnqueue(() => SectionListCollection = sectionListCollection);

        // Import Table
        var importsListCollection = new ObservableCollection<AdvancedGroupList>();
        foreach (var import in pe.DllImports)
        {
            var ImportsList = new AdvancedGroupList(new ObservableCollection<string>
            {
                "Characteristics: " + import.Characteristics,
                "Original First Thunk: " + import.OriginalFirstThunk,
                "Time Date Stamp: " + import.TimeDateStamp,
                "Forwarder Chain: " + import.ForwarderChain,
                "First Thunk: " + import.FirstThunk
            });
            ImportsList.Key = import.Name;
            importsListCollection.Add(ImportsList);
        }
        ThreadHelper.DispatcherQueue.TryEnqueue(() => ImportListCollection = importsListCollection);

        // Functions Table
        var functionsListCollection = new ObservableCollection<AdvancedGroupList>();
        foreach (var import in pe.DllImports)
        {
            var FunctionsList = new AdvancedGroupList(new ObservableCollection<string> { });
            foreach (var func in import.Functions)
            {
                FunctionsList.Add(func.Name);
            }
            FunctionsList.Key = import.Name;
            functionsListCollection.Add(FunctionsList);
        }
        ThreadHelper.DispatcherQueue.TryEnqueue(() => FunctionsListCollection = functionsListCollection);

        _initialised = true;
    }

    public async void Export()
    {
        var savePicker = new FileSavePicker();
        savePicker.FileTypeChoices.Add("JavaScript Object Notation", new List<string>() { ".json" });

        savePicker.SuggestedFileName = "export";

        var hwnd = WinRT.Interop.WindowNative.GetWindowHandle(App.Instance.WindowsManager.MainWindow);
        WinRT.Interop.InitializeWithWindow.Initialize(savePicker, hwnd);

        var file = await savePicker.PickSaveFileAsync();
        if (file == null) return;
        
        var notification = new ExportNotification(file);
        notification.StartExport();

        Windows.Storage.CachedFileManager.DeferUpdates(file);

        Dictionary<string, object> data = new Dictionary<string, object>()
        {
            {"Section Headers", _sectionListCollection},
            {"Import Table", _importsListCollection},
            {"Imported Functions", _functionsListCollection},
            {"File Properties", _propertiesListCollection},
            {"DOS Headers", _headersListCollection},
            {"Hashing", _hashesListCollection},
            {"NT Headers", _ntHeadersListCollection},
            {"Rich Headers", _richHeadersCollection}
        };

        await _factory.ExportAsync(file.Path, data);

        notification.ExportComplete();
    }

    public void OnSearch(AutoSuggestBox sender, AutoSuggestBoxQuerySubmittedEventArgs args)
    {
        Search = args.QueryText;
        LoadFileDetails();
        FilterCollection(SectionListCollection);
        FilterCollection(ImportListCollection);
        FilterCollection(FunctionsListCollection);
        FilterCollection(PropertiesListCollection);
        FilterCollection(HeadersListCollection);
        FilterCollection(HashesListCollection);
        FilterCollection(NTHeadersListCollection);
        FilterCollection(RichHeadersListCollection);
    }

    private void FilterCollection(ObservableCollection<AdvancedGroupList> collection)
    {
        foreach (var advancedGroupList in collection)
        {
            advancedGroupList.Filter = SearchFilter;
            advancedGroupList.RefreshFilter();
        }
    }

    private void OnSearchChanged(string search)
    {
        _search = search;
        SearchSuggestions.Filter = SearchFilter;
        SearchSuggestions.RefreshFilter();
    }

    private bool SearchFilter(object obj)
    {
        return string.IsNullOrEmpty(Search) || obj.ToString()!.ToLower().Contains(Search.ToLower());
    }

    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _initialised = false;
    }
}
