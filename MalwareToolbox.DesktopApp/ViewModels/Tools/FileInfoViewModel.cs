using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.DesktopApp.UI.Notifications;
using MalwareToolbox.Library.ImportExports;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using Microsoft.UI.Xaml;
using Newtonsoft.Json;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class FileInfoViewModel : ToolboxViewModel
{
    private readonly ImportExportFactory<Dictionary<string, List<string>>> _fileInfoFactory;
    private bool _initialised;
    private bool _filterChanged;
    private string _search;
    private ObservableCollection<GroupedList> _sectionListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _importsListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _functionsListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _propertiesListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _headersListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _hashesListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _ntHeadersListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _ntOptionalListCollection = new ObservableCollection<GroupedList>();


    public ObservableCollection<GroupedList> SectionListCollection
    {
        get => _sectionListCollection;
        set => SetProperty(ref _sectionListCollection, value);
    }
    public ObservableCollection<GroupedList> PropertiesListCollection
    {
        get => _propertiesListCollection;
        set => SetProperty(ref _propertiesListCollection, value);
    }
    public ObservableCollection<GroupedList> ImportListCollection
    {
        get => _importsListCollection;
        set => SetProperty(ref _importsListCollection, value);
    }
    public ObservableCollection<GroupedList> FunctionsListCollection
    {
        get => _functionsListCollection;
        set => SetProperty(ref _functionsListCollection, value);
    }
    public ObservableCollection<GroupedList> HeadersListCollection
    {
        get => _headersListCollection;
        set => SetProperty(ref _headersListCollection, value);
    }
    public ObservableCollection<GroupedList> HashesListCollection
    {
        get => _hashesListCollection;
        set => SetProperty(ref _hashesListCollection, value);
    }
    public ObservableCollection<GroupedList> NTHeadersListCollection
    {
        get => _ntHeadersListCollection;
        set => SetProperty(ref _ntHeadersListCollection, value);
    }
    public ObservableCollection<GroupedList> NTOptionalListCollection
    {
        get => _ntOptionalListCollection;
        set => SetProperty(ref _ntOptionalListCollection, value);
    }

    public string Search
    {
        get => _search;
        set => SetFilterProperty(ref _search, value);
    }
    public FileInfoViewModel()
    {
        _fileInfoFactory = ImportExportFactory<Dictionary<string, List<string>>>.ForStrings();
        FileManager.WinFileClosed += WinFileManager_WinFileClosed;
    }
    public void InitFileInfo()
    {
        if (!_initialised && FileManager.IsFileOpened())
        {
            _filterChanged = true;
            LoadFileDetails();
            _initialised = true;
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public void LoadFileDetails()
    {
        if (_initialised)
        {
            return;
        }
        

        // Get file for PE Info
        var pe = new PE(FileManager.WinFile);
        if (!pe.LoadHeaders())
        {
            Console.WriteLine("Failed to load PE");
            return;
        }



        // File Properties
        // var filePropertiesPath = pe.File.Path;
        _propertiesListCollection.Clear();
        var PropertiesList = new GroupedList(new List<string>
        {
            "Path: " + pe.File.Path,
            "Size: " + Convert.ToString(pe.File.Size),
            "Is DLL: " + Convert.ToString(pe.IsDLL()),
            "Is 64 bit: " + Convert.ToString(pe.Is64Bit())
        });
        _propertiesListCollection.Add(PropertiesList);


        // Dos Headers
        _headersListCollection.Clear();
        var HeadersList = new GroupedList(new List<string>
        {
            "Magic: " + pe.DosHeaders.Magic,
            "Lfanew: " + pe.DosHeaders.Lfanew
        });
        _headersListCollection.Add(HeadersList);

        // Hashes
        var md5Hash = new Md5Hasher(FileManager.WinFile);
        var sha256Hash = new Sha256Hasher(FileManager.WinFile);

        _hashesListCollection.Clear();
        var HashesList = new GroupedList(new List<string>
        {
            "MD5: " + Convert.ToHexString(md5Hash.Hash()),
            "SHA256: " + Convert.ToHexString(sha256Hash.Hash())
        });
        _hashesListCollection.Add(HashesList);

        // NT File Headers
        _ntHeadersListCollection.Clear();
        var NTHeadersList = new GroupedList(new List<string>
        {
            "Signature: " + Convert.ToString(pe.NtFileHeaders.Signature),
            "Machine: " + Convert.ToString(pe.NtFileHeaders.Machine),
            "NumberOfSections: " + Convert.ToString(pe.NtFileHeaders.NumberOfSections),
            "TimeDateStamp: " + Convert.ToString(pe.NtFileHeaders.TimeDateStamp),
            "PointerToSymbolTable: " + Convert.ToString(pe.NtFileHeaders.PointerToSymbolTable),
            "NumberOfSymbols: " + Convert.ToString(pe.NtFileHeaders.NumberOfSymbols),
            "SizeOfOptionalHeader: " + Convert.ToString(pe.NtFileHeaders.SizeOfOptionalHeader),
            "Characteristics: " + Convert.ToString(pe.NtFileHeaders.Characteristics)
        });
        _ntHeadersListCollection.Add(NTHeadersList);


        // NT Optional Headers
        _ntOptionalListCollection.Clear();
        var NTOptionalList = new GroupedList(new List<string>
        {
            "Magic: " + Convert.ToString(pe.NtOptionalHeaders.Magic),
            "MajorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorLinkerVersion),
            "MinorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorLinkerVersion),
            "SizeOfCode: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfCode),
            "SizeOfInitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfInitializedData),
            "SizeOfUninitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfUninitializedData),
            "AddressOfEntryPoint: " + Convert.ToString(pe.NtOptionalHeaders.AddressOfEntryPoint),
            "BaseOfCode: " + Convert.ToString(pe.NtOptionalHeaders.BaseOfCode),
            "SectionAlignment: " + Convert.ToString(pe.NtOptionalHeaders.SectionAlignment),
            "FileAlignment: " + Convert.ToString(pe.NtOptionalHeaders.FileAlignment),
            "MajorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorOperatingSystemVersion),
            "MinorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorOperatingSystemVersion),
            "MajorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorImageVersion),
            "MinorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorImageVersion),
            "MajorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorSubsystemVersion),
            "MinorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorSubsystemVersion),
            "Win32VersionValue: " + Convert.ToString(pe.NtOptionalHeaders.Win32VersionValue),
            "SizeOfImage: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfImage),
            "SizeOfHeaders: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfHeaders),
            "CheckSum: " + Convert.ToString(pe.NtOptionalHeaders.CheckSum),
            "Subsystem: " + Convert.ToString(pe.NtOptionalHeaders.Subsystem),
            "DllCharacteristics: " + Convert.ToString(pe.NtOptionalHeaders.DllCharacteristics),
            "LoaderFlags: " + Convert.ToString(pe.NtOptionalHeaders.LoaderFlags),
            "NumberOfRvaAndSizes: " + Convert.ToString(pe.NtOptionalHeaders.NumberOfRvaAndSizes)
        });
        _ntOptionalListCollection.Add(NTOptionalList);



        if (pe.Is64Bit())

        {
            NtOptionalHeader64 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader64)!;
            var NTOptionalList64 = new GroupedList(new List<string>
            {
            "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase),
            "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve),
            "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit),
            "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve),
            "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit),
            });
            _ntOptionalListCollection.Add(NTOptionalList64);
        }
        else
        {
            NtOptionalHeader32 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader32)!;
            var NTOptionalList32 = new GroupedList(new List<string>
            {
            "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase),
            "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve),
            "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit),
            "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve),
            "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit),
            });
            _ntOptionalListCollection.Add(NTOptionalList32);
        }


        _sectionListCollection.Clear();
        foreach (var section in pe.SectionHeaders)
        {
            var SectionHeaderList = new GroupedList(new List<string> { "Virtual Size: " + section.VirtualSize, "Virtual Address: " + section.VirtualAddress, "Size Of Raw Data: " + section.SizeOfRawData, "Pointer to Raw Data: " + section.PointerToRawData });
            SectionHeaderList.Key = section.Name;
            _sectionListCollection.Add(SectionHeaderList);
        }

        // Import Table
        _importsListCollection.Clear();
        foreach (var import in pe.DllImports)
        {
            var ImportsList = new GroupedList(new List<string>
            {
                "Characteristics: " + import.Characteristics,
                "Original First Thunk: " + import.OriginalFirstThunk,
                "Time Date Stamp: " + import.TimeDateStamp,
                "Forwarder Chain: " + import.ForwarderChain,
                "First Thunk: " + import.FirstThunk
            });
            ImportsList.Key = import.Name;
            _importsListCollection.Add(ImportsList);
        }
        // Functions Table
        _functionsListCollection.Clear();
        foreach (var import in pe.DllImports)
        {
            var FunctionsList = new GroupedList(new List<string> { });
            foreach (var func in import.Functions)
            {
                FunctionsList.Add(func.Name);
            }
            FunctionsList.Key = import.Name;
            _functionsListCollection.Add(FunctionsList);
        }

        _initialised = true;
    }
    private bool SetFilterProperty<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string propertyName = null)
    {
        var result = SetProperty(ref field, newValue, propertyName);
        if (result) _filterChanged = true;
        return result;
    }

    private bool SetFilterProperty<T>(Config<T> config, T newValue, [CallerMemberName] string propertyName = null)
    {
        var result = SetProperty(config, newValue, propertyName);
        if (result) _filterChanged = true;
        return result;
    }
    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _initialised = false;
        _filterChanged = false;
    }
}
