using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.Library.ImportExports;
using MalwareToolbox.Library.Utils;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using MalwareToolbox.LibraryC.Utils;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class FileInfoViewModel : ToolboxViewModel
{
    private readonly ImportExportFactory<Dictionary<string, List<string>>> _fileInfoFactory;
    private bool _initialised;
    private bool _filterChanged;
    private bool _validPE;
    private string _search;
    private ObservableCollection<GroupedList> _sectionListCollection;
    private ObservableCollection<GroupedList> _importsListCollection;
    private ObservableCollection<GroupedList> _functionsListCollection;
    private ObservableCollection<GroupedList> _propertiesListCollection;
    private ObservableCollection<GroupedList> _headersListCollection;
    private ObservableCollection<GroupedList> _hashesListCollection;
    private ObservableCollection<GroupedList> _ntHeadersListCollection;
    private ObservableCollection<GroupedList> _ntOptionalListCollection;
    private ObservableCollection<GroupedList> _richHeadersCollection;

    public bool ValidPE
    {
        get => _validPE;
        set => SetProperty(ref _validPE, value);
    }

    public ObservableCollection<GroupedList> SectionListCollection
    {
        get => _sectionListCollection;
        set => SetProperty(ref _sectionListCollection, value);
    }
    public ObservableCollection<GroupedList> PropertiesListCollection
    {
        get => _propertiesListCollection;
        set => SetProperty(ref _propertiesListCollection, value);
    }
    public ObservableCollection<GroupedList> ImportListCollection
    {
        get => _importsListCollection;
        set => SetProperty(ref _importsListCollection, value);
    }
    public ObservableCollection<GroupedList> FunctionsListCollection
    {
        get => _functionsListCollection;
        set => SetProperty(ref _functionsListCollection, value);
    }
    public ObservableCollection<GroupedList> HeadersListCollection
    {
        get => _headersListCollection;
        set => SetProperty(ref _headersListCollection, value);
    }
    public ObservableCollection<GroupedList> HashesListCollection
    {
        get => _hashesListCollection;
        set => SetProperty(ref _hashesListCollection, value);
    }
    public ObservableCollection<GroupedList> NTHeadersListCollection
    {
        get => _ntHeadersListCollection;
        set => SetProperty(ref _ntHeadersListCollection, value);
    }
    public ObservableCollection<GroupedList> NTOptionalListCollection
    {
        get => _ntOptionalListCollection;
        set => SetProperty(ref _ntOptionalListCollection, value);
    }

    public ObservableCollection<GroupedList> RichHeadersListCollection
    {
        get => _ntHeadersListCollection;
        set => SetProperty(ref _richHeadersCollection, value);
    }

    public string Search
    {
        get => _search;
        set => SetFilterProperty(ref _search, value);
    }

    public FileInfoViewModel()
    {
        _fileInfoFactory = ImportExportFactory<Dictionary<string, List<string>>>.ForStrings();
        FileManager.WinFileClosed += WinFileManager_WinFileClosed;
    }

    public async void InitFileInfo()
    {
        if (!_initialised && FileManager.IsFileOpened)
        {
            _filterChanged = true;
            await Task.Run(LoadFileDetails);
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public void LoadFileDetails()
    {
        if (_initialised) return;

        // File Properties
        var propertiesListCollection = new ObservableCollection<GroupedList>();
        var PropertiesList = new GroupedList(new List<string>
        {
            "Path: " + FileManager.WinFile.Path,
        });

        var fileProps = FileManager.GetWrapper<WinFileProps>();
        if (fileProps != null)
        {
            PropertiesList.Add("FileSize: " + ToolboxConverters.SizeToString(fileProps.FileSize));
            PropertiesList.Add("CreationTime: " + fileProps.CreationTime.ToString());
            PropertiesList.Add("LastAccessTime: " + fileProps.LastAccessTime.ToString());
            PropertiesList.Add("LastWriteTime: " + fileProps.LastWriteTime.ToString());
        }

        propertiesListCollection.Add(PropertiesList);

        // Hashes
        var md5Hash = new Md5Hasher(FileManager.WinFile);
        var sha256Hash = new Sha256Hasher(FileManager.WinFile);

        var hashesListCollection = new ObservableCollection<GroupedList>();
        var HashesList = new GroupedList(new List<string>
        {
            "MD5: " + Convert.ToHexString(md5Hash.Hash()),
            "SHA256: " + Convert.ToHexString(sha256Hash.Hash())
        });
        hashesListCollection.Add(HashesList);
        ThreadHelper.DispatcherQueue.TryEnqueue(() => HashesListCollection = hashesListCollection);

        // Get file for PE Info
        var pe = new PE(FileManager.WinFile);
        if (!pe.LoadHeaders())
        {
            ThreadHelper.DispatcherQueue.TryEnqueue(() =>
            {
                PropertiesListCollection = propertiesListCollection;
                ValidPE = false;
            });
            return;
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() => ValidPE = true);

        // Basic PE info
        PropertiesList.Add("Is DLL: " + Convert.ToString(pe.IsDLL()));
        PropertiesList.Add("Is 64 bit: " + Convert.ToString(pe.Is64Bit()));
        ThreadHelper.DispatcherQueue.TryEnqueue(() => PropertiesListCollection = propertiesListCollection);

        // Dos Headers
        var headersListCollection = new ObservableCollection<GroupedList>();
        var HeadersList = new GroupedList(new List<string>
        {
            "E_Magic: " + pe.DosHeaders.Magic,
            "E_Lfanew: " + pe.DosHeaders.Lfanew
        });
        headersListCollection.Add(HeadersList);
        ThreadHelper.DispatcherQueue.TryEnqueue(() => HeadersListCollection = headersListCollection);

        // NT Headers
        var ntHeadersListCollection = new ObservableCollection<GroupedList>();
        var NTHeadersList = new GroupedList(new List<string>
        {
            Convert.ToString(pe.NtFileHeaders.Signature),
        });
        NTHeadersList.Key = "Signature";
        ntHeadersListCollection.Add(NTHeadersList);

        var NTFileHeadersList = new GroupedList(new List<string>
        {
            "Machine: " + Convert.ToString(pe.NtFileHeaders.Machine),
            "NumberOfSections: " + Convert.ToString(pe.NtFileHeaders.NumberOfSections),
            "TimeDateStamp: " + Convert.ToString(pe.NtFileHeaders.TimeDateStamp),
            "PointerToSymbolTable: " + Convert.ToString(pe.NtFileHeaders.PointerToSymbolTable),
            "NumberOfSymbols: " + Convert.ToString(pe.NtFileHeaders.NumberOfSymbols),
            "SizeOfOptionalHeader: " + Convert.ToString(pe.NtFileHeaders.SizeOfOptionalHeader),
            "Characteristics: " + Convert.ToString(pe.NtFileHeaders.Characteristics)
        });
        NTFileHeadersList.Key = "NT File Header";
        ntHeadersListCollection.Add(NTFileHeadersList);
        ThreadHelper.DispatcherQueue.TryEnqueue(() => NTHeadersListCollection = ntHeadersListCollection);

        // NT Optional Headers
        var NTOptionalList = new GroupedList(new List<string>
        {
            "Magic: " + Convert.ToString(pe.NtOptionalHeaders.Magic),
            "MajorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorLinkerVersion),
            "MinorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorLinkerVersion),
            "SizeOfCode: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfCode),
            "SizeOfInitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfInitializedData),
            "SizeOfUninitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfUninitializedData),
            "AddressOfEntryPoint: " + Convert.ToString(pe.NtOptionalHeaders.AddressOfEntryPoint),
            "BaseOfCode: " + Convert.ToString(pe.NtOptionalHeaders.BaseOfCode),
            "SectionAlignment: " + Convert.ToString(pe.NtOptionalHeaders.SectionAlignment),
            "FileAlignment: " + Convert.ToString(pe.NtOptionalHeaders.FileAlignment),
            "MajorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorOperatingSystemVersion),
            "MinorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorOperatingSystemVersion),
            "MajorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorImageVersion),
            "MinorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorImageVersion),
            "MajorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorSubsystemVersion),
            "MinorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorSubsystemVersion),
            "Win32VersionValue: " + Convert.ToString(pe.NtOptionalHeaders.Win32VersionValue),
            "SizeOfImage: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfImage),
            "SizeOfHeaders: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfHeaders),
            "CheckSum: " + Convert.ToString(pe.NtOptionalHeaders.CheckSum),
            "Subsystem: " + Convert.ToString(pe.NtOptionalHeaders.Subsystem),
            "DllCharacteristics: " + Convert.ToString(pe.NtOptionalHeaders.DllCharacteristics),
            "LoaderFlags: " + Convert.ToString(pe.NtOptionalHeaders.LoaderFlags),
            "NumberOfRvaAndSizes: " + Convert.ToString(pe.NtOptionalHeaders.NumberOfRvaAndSizes)
        });
        NTOptionalList.Key = "NT Optional Header";
        ntHeadersListCollection.Add(NTOptionalList);

        if (pe.Is64Bit())

        {
            NtOptionalHeader64 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader64)!;
            var NTOptionalList64 = new GroupedList(new List<string>
            {
            "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase),
            "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve),
            "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit),
            "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve),
            "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit),
            });
            NTOptionalList64.Key = "NT Optional Header 64";
            ntHeadersListCollection.Add(NTOptionalList64);
        }
        else
        {
            NtOptionalHeader32 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader32)!;
            var NTOptionalList32 = new GroupedList(new List<string>
            {
            "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase),
            "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve),
            "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit),
            "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve),
            "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit),
            });
            NTOptionalList32.Key = "NT Optional Header 32";
            ntHeadersListCollection.Add(NTOptionalList32);
        }


        // Rich Headers
        var richHeadersListCollection = new ObservableCollection<GroupedList>();

        var RichHeadersList = new GroupedList(new List<string>
        {
            "Size: " + Convert.ToString(pe.richheaders.size),
            "DansOffset: " + Convert.ToString(pe.richheaders.DansOffset),
            "EntryNo: " + Convert.ToString(pe.richheaders.entryno),
            "DecryptionKey: " + Convert.ToString(pe.richheaders.DecryptionKey)
        });
        RichHeadersList.Key = "Details";
        richHeadersListCollection.Add(RichHeadersList);


        foreach (var entry in pe.richheaders.entries)
        {
            var RichHeadersEntriesList = new GroupedList(new List<string> { Convert.ToString(entry) });
            RichHeadersEntriesList.Key = "Entries";
            richHeadersListCollection.Add(RichHeadersEntriesList);
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() => RichHeadersListCollection = richHeadersListCollection);


        // Sections
        var sectionListCollection = new ObservableCollection<GroupedList>();
        foreach (var section in pe.SectionHeaders)
        {
            var SectionHeaderList = new GroupedList(new List<string> { "Virtual Size: " + section.VirtualSize, "Virtual Address: " + section.VirtualAddress, "Size Of Raw Data: " + section.SizeOfRawData, "Pointer to Raw Data: " + section.PointerToRawData });
            SectionHeaderList.Key = section.Name;
            sectionListCollection.Add(SectionHeaderList);
        }
        ThreadHelper.DispatcherQueue.TryEnqueue(() => SectionListCollection = sectionListCollection);

        // Import Table
        var importsListCollection = new ObservableCollection<GroupedList>();
        foreach (var import in pe.DllImports)
        {
            var ImportsList = new GroupedList(new List<string>
            {
                "Characteristics: " + import.Characteristics,
                "Original First Thunk: " + import.OriginalFirstThunk,
                "Time Date Stamp: " + import.TimeDateStamp,
                "Forwarder Chain: " + import.ForwarderChain,
                "First Thunk: " + import.FirstThunk
            });
            ImportsList.Key = import.Name;
            importsListCollection.Add(ImportsList);
        }
        ThreadHelper.DispatcherQueue.TryEnqueue(() => ImportListCollection = importsListCollection);

        // Functions Table
        var functionsListCollection = new ObservableCollection<GroupedList>();
        foreach (var import in pe.DllImports)
        {
            var FunctionsList = new GroupedList(new List<string> { });
            foreach (var func in import.Functions)
            {
                FunctionsList.Add(func.Name);
            }
            FunctionsList.Key = import.Name;
            functionsListCollection.Add(FunctionsList);
        }
        ThreadHelper.DispatcherQueue.TryEnqueue(() => FunctionsListCollection = functionsListCollection);

        _initialised = true;
    }
    private bool SetFilterProperty<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string propertyName = null)
    {
        var result = SetProperty(ref field, newValue, propertyName);
        if (result) _filterChanged = true;
        return result;
    }

    private bool SetFilterProperty<T>(Config<T> config, T newValue, [CallerMemberName] string propertyName = null)
    {
        var result = SetProperty(config, newValue, propertyName);
        if (result) _filterChanged = true;
        return result;
    }
    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _initialised = false;
        _filterChanged = false;
    }
}
