using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.DesktopApp.UI.Notifications;
using MalwareToolbox.Library.ImportExports;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using Microsoft.UI.Xaml;
using Newtonsoft.Json;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class FileInfoViewModel : ToolboxViewModel
{
    private readonly ImportExportFactory<Dictionary<string, List<string>>> _fileInfoFactory;
    private bool _initialised;
    private bool _filterChanged;
    private string _search;
    private ObservableCollection<GroupedList> _sectionListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _importsListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _functionsListCollection = new ObservableCollection<GroupedList>();
    private ObservableCollection<GroupedList> _propertiesListCollection = new ObservableCollection<GroupedList>();
    //private ObservableCollection<GroupedList> _headersListCollection = new ObservableCollection<GroupedList>();
    //private ObservableCollection<GroupedList> _hashesListCollection = new ObservableCollection<GroupedList>();
    //private ObservableCollection<GroupedList> _ntHeadersListCollection = new ObservableCollection<GroupedList>();
    //private ObservableCollection<GroupedList> _ntOptionalListCollection = new ObservableCollection<GroupedList>();


    public ObservableCollection<GroupedList> SectionListCollection
    {
        get => _sectionListCollection;
        set => SetProperty(ref _sectionListCollection, value);
    }
    public ObservableCollection<GroupedList> PropertiesListCollection
    {
        get => _propertiesListCollection;
        set => SetProperty(ref _propertiesListCollection, value);
    }
    public ObservableCollection<GroupedList> ImportListCollection
    {
        get => _importsListCollection;
        set => SetProperty(ref _importsListCollection, value);
    }
    public ObservableCollection<GroupedList> FunctionsListCollection
    {
        get => _functionsListCollection;
        set => SetProperty(ref _functionsListCollection, value);
    }

    public string Search
    {
        get => _search;
        set => SetFilterProperty(ref _search, value);
    }
    public FileInfoViewModel()
    {
        _fileInfoFactory = ImportExportFactory<Dictionary<string, List<string>>>.ForStrings();
        FileManager.WinFileClosed += WinFileManager_WinFileClosed;
    }
    public void InitFileInfo()
    {
        if (!_initialised && FileManager.IsFileOpened())
        {
            _filterChanged = true;
            LoadFileDetails();
            _initialised = true;
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public void LoadFileDetails()
    {
        if (_initialised)
        {
            return;
        }
        

        // Get file for PE Info
        var pe = new PE(FileManager.WinFile);
        if (!pe.LoadHeaders())
        {
            Console.WriteLine("Failed to load PE");
            return;
        }



        // File Properties
        // var filePropertiesPath = pe.File.Path;
        _propertiesListCollection.Clear();
        foreach (var import in pe.DllImports)
        {
            var PropertiesList = new GroupedList(new List<string>
            {
                "Path: " + pe.File.Path,
                "Size: " + Convert.ToString(pe.File.Size),
                "Is DLL: " + Convert.ToString(pe.IsDLL()),
                "Is 64 bit: " + Convert.ToString(pe.Is64Bit())
            });

            _propertiesListCollection.Add(PropertiesList);
        }

        //// Dos Headers
        //dosHeadersMagicText.Text = "Magic: " + Convert.ToString(pe.DosHeaders.Magic);
        //dosHeadersLfanewText.Text = "Lfanew: " + Convert.ToString(pe.DosHeaders.Lfanew);

        //// Hashes
        //var md5Hash = new Md5Hasher(_fileManager.WinFile);
        //md5HashText.Text = "MD5: " + Convert.ToHexString(md5Hash.Hash());
        //var sha256Hash = new Sha256Hasher(_fileManager.WinFile);
        //sha256HashText.Text = "SHA256: " + Convert.ToHexString(sha256Hash.Hash());

        //// NT File Headers
        //fileSignatureText.Text = "Signature: " + Convert.ToString(pe.NtFileHeaders.Signature);
        //fileMachineText.Text = "Machine: " + Convert.ToString(pe.NtFileHeaders.Machine);
        //fileSectionsText.Text = "NumberOfSections: " + Convert.ToString(pe.NtFileHeaders.NumberOfSections);
        //fileTimeDateStampText.Text = "TimeDateStamp: " + Convert.ToString(pe.NtFileHeaders.TimeDateStamp);
        //filePointerToSymbolText.Text = "PointerToSymbolTable: " + Convert.ToString(pe.NtFileHeaders.PointerToSymbolTable);
        //fileSymbolsText.Text = "NumberOfSymbols: " + Convert.ToString(pe.NtFileHeaders.NumberOfSymbols);
        //fileOptionalHeaderText.Text = "SizeOfOptionalHeader: " + Convert.ToString(pe.NtFileHeaders.SizeOfOptionalHeader);
        //fileCharacteristicsText.Text = "Characteristics: " + Convert.ToString(pe.NtFileHeaders.Characteristics);

        //// NT Optional Headers
        //fileMagicText.Text = "Magic: " + Convert.ToString(pe.NtOptionalHeaders.Magic);
        //majorLinkerVersionText.Text = "MajorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorLinkerVersion);
        //minorLinkerVersionText.Text = "MinorLinkerVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorLinkerVersion);
        //sizeOfCodeText.Text = "SizeOfCode: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfCode);
        //sizeOfInitializedDataText.Text = "SizeOfInitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfInitializedData);
        //sizeOfUninitializedDataText.Text = "SizeOfUninitializedData: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfUninitializedData);
        //addressOfEntryPointText.Text = "AddressOfEntryPoint: " + Convert.ToString(pe.NtOptionalHeaders.AddressOfEntryPoint);
        //baseOfCodeText.Text = "BaseOfCode: " + Convert.ToString(pe.NtOptionalHeaders.BaseOfCode);
        //sectionAlignmentText.Text = "SectionAlignment: " + Convert.ToString(pe.NtOptionalHeaders.SectionAlignment);
        //fileAlignmentText.Text = "FileAlignment: " + Convert.ToString(pe.NtOptionalHeaders.FileAlignment);
        //majorOperatingSystemVersionText.Text = "MajorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorOperatingSystemVersion);
        //minorOperatingSystemVersionText.Text = "MinorOperatingSystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorOperatingSystemVersion);
        //majorImageVersionText.Text = "MajorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorImageVersion);
        //minorImageVersionText.Text = "MinorImageVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorImageVersion);
        //majorSubsystemVersionText.Text = "MajorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MajorSubsystemVersion);
        //minorSubsystemVersionText.Text = "MinorSubsystemVersion: " + Convert.ToString(pe.NtOptionalHeaders.MinorSubsystemVersion);
        //win32VersionValueText.Text = "Win32VersionValue: " + Convert.ToString(pe.NtOptionalHeaders.Win32VersionValue);
        //sizeOfImageText.Text = "SizeOfImage: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfImage);
        //sizeOfHeadersText.Text = "SizeOfHeaders: " + Convert.ToString(pe.NtOptionalHeaders.SizeOfHeaders);
        //checkSumText.Text = "CheckSum: " + Convert.ToString(pe.NtOptionalHeaders.CheckSum);
        //subSystemText.Text = "Subsystem: " + Convert.ToString(pe.NtOptionalHeaders.Subsystem);
        //dllCharacteristicsText.Text = "DllCharacteristics: " + Convert.ToString(pe.NtOptionalHeaders.DllCharacteristics);
        //loaderFlagsText.Text = "LoaderFlags: " + Convert.ToString(pe.NtOptionalHeaders.LoaderFlags);
        //numberOfRvaAndSizesText.Text = "NumberOfRvaAndSizes: " + Convert.ToString(pe.NtOptionalHeaders.NumberOfRvaAndSizes);


        //if (pe.Is64Bit())

        //{
        //    NtOptionalHeader64 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader64)!;
        //    var imageBase = ntOptionalHeaders.ImageBase;
        //    imageBaseText.Text = "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase);
        //    sizeOfStackReserveText.Text = "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve);
        //    sizeOfStackCommitText.Text = "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit);
        //    sizeOfHeapReserveText.Text = "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve);
        //    sizeOfHeapCommitText.Text = "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit);
        //}
        //else
        //{
        //    NtOptionalHeader32 ntOptionalHeaders = (pe.NtOptionalHeaders as NtOptionalHeader32)!;
        //    imageBaseText.Text = "ImageBase: " + Convert.ToString(ntOptionalHeaders.ImageBase);
        //    sizeOfStackReserveText.Text = "SizeOfStackReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfStackReserve);
        //    sizeOfStackCommitText.Text = "SizeOfStackCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfStackCommit);
        //    sizeOfHeapReserveText.Text = "SizeOfHeapReserve: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapReserve);
        //    sizeOfHeapCommitText.Text = "SizeOfHeapCommit: " + Convert.ToString(ntOptionalHeaders.SizeOfHeapCommit);
        //}

        _sectionListCollection.Clear();
        foreach (var section in pe.SectionHeaders)
        {
            var SectionHeaderList = new GroupedList(new List<string> { "Virtual Size: " + section.VirtualSize, "Virtual Address: " + section.VirtualAddress, "Size Of Raw Data: " + section.SizeOfRawData, "Pointer to Raw Data: " + section.PointerToRawData });
            SectionHeaderList.Key = section.Name;
            _sectionListCollection.Add(SectionHeaderList);
        }

        // Import Table
        _importsListCollection.Clear();
        foreach (var import in pe.DllImports)
        {
            var ImportsList = new GroupedList(new List<string>
            {
                "Characteristics: " + import.Characteristics,
                "Original First Thunk: " + import.OriginalFirstThunk,
                "Time Date Stamp: " + import.TimeDateStamp,
                "Forwarder Chain: " + import.ForwarderChain,
                "First Thunk: " + import.FirstThunk
            });
            ImportsList.Key = import.Name;
            _importsListCollection.Add(ImportsList);
        }
        // Functions Table
        _functionsListCollection.Clear();
        foreach (var import in pe.DllImports)
        {
            var FunctionsList = new GroupedList(new List<string> { });
            foreach (var func in import.Functions)
            {
                FunctionsList.Add(func.Name);
            }
            FunctionsList.Key = import.Name;
            _functionsListCollection.Add(FunctionsList);
        }

        _initialised = true;
    }
    private bool SetFilterProperty<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string propertyName = null)
    {
        var result = SetProperty(ref field, newValue, propertyName);
        if (result) _filterChanged = true;
        return result;
    }

    private bool SetFilterProperty<T>(Config<T> config, T newValue, [CallerMemberName] string propertyName = null)
    {
        var result = SetProperty(config, newValue, propertyName);
        if (result) _filterChanged = true;
        return result;
    }
    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _initialised = false;
        _filterChanged = false;
    }
}
