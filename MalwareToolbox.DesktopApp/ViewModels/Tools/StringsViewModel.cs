using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.LibraryC.Strings;
using Microsoft.UI.Xaml;
using Newtonsoft.Json;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class StringsViewModel : ToolboxViewModel
{
    private bool _filterChanged;
    private StringAnalyser _stringAnalyser;
    private bool _initialised;

    private bool _loading;
    private ObservableCollection<GroupedList> _stringsCollection;
    private string _search;

    public bool Loading
    {
        get => _loading;
        set => SetProperty(ref _loading, value);
    }

    public ObservableCollection<GroupedList> StringsCollection
    {
        get => _stringsCollection;
        set => SetProperty(ref _stringsCollection, value);
    }

    public string Search
    {
        get => _search;
        set => SetFilterProperty(ref _search, value);
    }

    public double MinLength
    {
        get => ConfigProvider.GetConfig(Configs.StringsMinLength);
        set => SetFilterProperty(Configs.StringsMinLength, (int)value);
    }

    public double MaxLength
    {
        get => ConfigProvider.GetConfig(Configs.StringsMaxLength);
        set => SetFilterProperty(Configs.StringsMaxLength, (int)value);
    }

    public StringsDuplicateMode DuplicateMode
    {
        get => ConfigProvider.GetConfig(Configs.StringsStringsDuplicateMode);
        set => SetFilterProperty(Configs.StringsStringsDuplicateMode, value);
    }

    public StringsMatchingMode MatchingMode
    {
        get => ConfigProvider.GetConfig(Configs.StringsStringsMatchingMode);
        set => SetFilterProperty(Configs.StringsStringsMatchingMode, value);
    }

    public StringsSortOrder SortOrder
    {
        get => ConfigProvider.GetConfig(Configs.StringsStringsSortOrder);
        set => SetFilterProperty(Configs.StringsStringsSortOrder, value);
    }

    public StringsSortDirection SortDirection
    {
        get => ConfigProvider.GetConfig(Configs.StringsStringsSortDirection);
        set => SetFilterProperty(Configs.StringsStringsSortDirection, value);
    }

    public StringsViewModel()
    {
        FileManager.WinFileClosed += WinFileManager_WinFileClosed;
    }

    public void InitStrings()
    {
        if (!_initialised && FileManager.IsFileOpened())
        {
            _initialised = true;
            _filterChanged = true;
            _stringAnalyser = new StringAnalyser(FileManager.WinFile);
            LoadStringsAsync();
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public async void LoadStringsAsync()
    {
        if (!_filterChanged || Loading) return;

        Loading = true;
        StringsCollection = await Task.Run(() =>
        {
            var observableCollection = new ObservableCollection<GroupedList>();
            GroupedList unkonwn = null;
            foreach (var keyValuePair in _stringAnalyser.GetStrings(new StringFilter(
                         (int)MinLength, 
                         (int)MaxLength,
                         Search,
                         MatchingMode,
                         SortOrder,
                         SortDirection
                    )))
            {
                //TODO Fix this very hacky way of making unknown category at the bottom
                if (keyValuePair.Key == "Unknown")
                {
                    unkonwn = new GroupedList(keyValuePair.Value) { Key = keyValuePair.Key };
                }
                else
                {
                    observableCollection.Add(new GroupedList(keyValuePair.Value) { Key = keyValuePair.Key });
                }
            }

            if (unkonwn != null)
            {
                observableCollection.Add(unkonwn);
            }

            return observableCollection;
        });
        Loading = false;
        _filterChanged = false;
    }

    public async void ExportStrings()
    {
        var savePicker = new Windows.Storage.Pickers.FileSavePicker();
        savePicker.FileTypeChoices.Add("Plain Text", new List<string>() { ".txt" });
        savePicker.FileTypeChoices.Add("JavaScript Object Notation", new List<string>() { ".json" });

        savePicker.SuggestedFileName = "export";

        var hwnd = WinRT.Interop.WindowNative.GetWindowHandle((Application.Current as App)?.MainWindow);
        WinRT.Interop.InitializeWithWindow.Initialize(savePicker, hwnd);

        var file = await savePicker.PickSaveFileAsync();
        if (file != null)
        {
            Windows.Storage.CachedFileManager.DeferUpdates(file);

            if (file.FileType == ".txt")
            {
                StringBuilder stringBuilder = new StringBuilder();
                foreach (var groupedList in StringsCollection)
                {
                    foreach (string stringItem in groupedList)
                    {
                        stringBuilder.AppendLine(stringItem);
                    }
                }

                await Windows.Storage.FileIO.WriteTextAsync(file, stringBuilder.ToString());
            }
            else if (file.FileType == ".json")
            {
                var content = JsonConvert.SerializeObject(StringsCollection);

                await Windows.Storage.FileIO.WriteTextAsync(file, content);
            }
            else
            {
                //TODO Dialog file type not supported
            }
        }
    }

    private bool SetFilterProperty<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string propertyName = null)
    {
        _filterChanged = true;
        return SetProperty(ref field, newValue, propertyName);
    }

    private bool SetFilterProperty<T>(Config<T> config, T newValue, [CallerMemberName] string propertyName = null)
    {
        _filterChanged = true;
        return SetProperty(config, newValue, propertyName);
    }
    

    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _initialised = false;
        _filterChanged = false;
        _stringAnalyser = null;
        StringsCollection = null;
    }
}
