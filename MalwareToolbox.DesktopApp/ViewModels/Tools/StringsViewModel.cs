using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using ColorCode.Common;
using CommunityToolkit.Mvvm.ComponentModel;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.LibraryC.Strings;
using Microsoft.UI.Xaml;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class StringsViewModel : ObservableRecipient
{
    private readonly ConfigProvider _configProvider;
    private readonly WinFileManager _fileManager;

    private bool _filterChanged;
    private StringAnalyser _stringAnalyser;

    private bool _loading;
    private ObservableCollection<GroupedList> _stringsCollection;
    private string _search;

    public bool Loading
    {
        get => _loading;
        set => SetProperty(ref _loading, value);
    }

    public ObservableCollection<GroupedList> StringsCollection
    {
        get => _stringsCollection;
        set => SetProperty(ref _stringsCollection, value);
    }

    public string Search
    {
        get => _search;
        set => SetFilterProperty(ref _search, value);
    }

    public double MinLength
    {
        get => _configProvider.GetConfig(Configs.StringsMinLength);
        set => SetProperty(Configs.StringsMinLength, (int)value);
    }

    public double MaxLength
    {
        get => _configProvider.GetConfig(Configs.StringsMaxLength);
        set => SetProperty(Configs.StringsMaxLength, (int)value);
    }

    public StringsDuplicateMode DuplicateMode
    {
        get => _configProvider.GetConfig(Configs.StringsStringsDuplicateMode);
        set => SetProperty(Configs.StringsStringsDuplicateMode, value);
    }

    public StringsMatchingMode MatchingMode
    {
        get => _configProvider.GetConfig(Configs.StringsStringsMatchingMode);
        set => SetProperty(Configs.StringsStringsMatchingMode, value);
    }

    public StringsSortOrder SortOrder
    {
        get => _configProvider.GetConfig(Configs.StringsStringsSortOrder);
        set => SetProperty(Configs.StringsStringsSortOrder, value);
    }

    public StringsSortDirection SortDirection
    {
        get => _configProvider.GetConfig(Configs.StringsStringsSortDirection);
        set => SetProperty(Configs.StringsStringsSortDirection, value);
    }

    public StringsViewModel()
    {
        _configProvider = App.Instance.ConfigProvider;
        _fileManager = App.Instance.WinFileManager;
        _fileManager.WinFileClosed += WinFileManager_WinFileClosed;
    }

    public void InitStrings()
    {
        if (_stringAnalyser == null && _fileManager.IsFileOpened())
        {
            _stringAnalyser = new StringAnalyser(_fileManager.WinFile);
            _filterChanged = true;
            LoadStringsAsync();
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public async void LoadStringsAsync()
    {
        if (!_filterChanged || Loading) return;

        Loading = true;
        StringsCollection = await Task.Run(() =>
        {
            var observableCollection = new ObservableCollection<GroupedList>();
            GroupedList unkonwn = null;
            foreach (var keyValuePair in _stringAnalyser.GetStrings(new StringFilter(
                         (int)MinLength, 
                         (int)MaxLength,
                         Search,
                         MatchingMode,
                         SortOrder,
                         SortDirection
                    )))
            {
                //TODO Fix this very hacky way of making unknown category at the bottom
                if (keyValuePair.Key == "Unknown")
                {
                    unkonwn = new GroupedList(keyValuePair.Value) { Key = keyValuePair.Key };
                }
                else
                {
                    observableCollection.Add(new GroupedList(keyValuePair.Value) { Key = keyValuePair.Key });
                }
            }

            if (unkonwn != null)
            {
                observableCollection.Add(unkonwn);
            }

            return observableCollection;
        });
        Loading = false;
        _filterChanged = false;
    }

    private bool SetFilterProperty<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string propertyName = null)
    {
        _filterChanged = true;
        return SetProperty(ref field, newValue, propertyName);
    }

    protected bool SetProperty<T>(Config<T> config, T value, [CallerMemberName] string propertyName = null)
    {
        // We duplicate the code here instead of calling the overload because we can't
        // guarantee that the invoked SetProperty<T> will be inlined, and we need the JIT
        // to be able to see the full EqualityComparer<T>.Default.Equals call, so that
        // it'll use the intrinsics version of it and just replace the whole invocation
        // with a direct comparison when possible (eg. for primitive numeric types).
        // This is the fastest SetProperty<T> overload so we particularly care about
        // the codegen quality here, and the code is small and simple enough so that
        // duplicating it still doesn't make the whole class harder to maintain.

        if (EqualityComparer<T>.Default.Equals(_configProvider.GetConfig(config), value))
        {
            return false;
        }

        _filterChanged = true;
        
        OnPropertyChanging(propertyName);

        _configProvider.SetConfig(config, value);

        OnPropertyChanged(propertyName);

        return true;
    }    

    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _stringAnalyser = null;
        StringsCollection = null;
    }
}
