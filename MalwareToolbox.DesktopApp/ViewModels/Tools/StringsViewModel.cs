using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using CommunityToolkit.Mvvm.ComponentModel;
using MalwareToolbox.DesktopApp.Core.Configurations;
using MalwareToolbox.DesktopApp.Core.Utils;
using MalwareToolbox.DesktopApp.Core.WindowFiles;
using MalwareToolbox.LibraryC.Strings;
using Microsoft.UI.Xaml;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools;

public class StringsViewModel : ObservableRecipient
{
    private readonly ConfigProvider _configProvider;

    private readonly WinFileManager _fileManager;
    private StringAnalyser _stringAnalyser;

    //todo save defaults
    private bool _loading;
    private bool _filterChanged;
    private ObservableCollection<GroupedList> _stringsCollection;
    private double _maxLength = 100;
    private string _search;
    private StringsDuplicateMode _duplicateMode = StringsDuplicateMode.Keep;

    public bool Loading
    {
        get => _loading;
        set => SetProperty(ref _loading, value);
    }

    public ObservableCollection<GroupedList> StringsCollection
    {
        get => _stringsCollection;
        set => SetProperty(ref _stringsCollection, value);
    }

    public double MinLength
    {
        get => _configProvider.GetConfig(Configs.StringsMinLength);
        set => SetProperty(Configs.StringsMinLength, (int)value);
    }

    public double MaxLength
    {
        get => _maxLength;
        set => SetFilterProperty(ref _maxLength, (int)value);
    }

    public string Search
    {
        get => _search;
        set => SetFilterProperty(ref _search, value);
    }

    public StringsDuplicateMode DuplicateMode
    {
        get => _duplicateMode;
        set => SetFilterProperty(ref _duplicateMode, value);
    }

    public StringsViewModel()
    {
        _fileManager = (Application.Current as App)!.MainWindow.FileManager;
        _fileManager.WinFileClosed += WinFileManager_WinFileClosed;
        _configProvider = new ConfigProvider();
    }

    public void InitStrings()
    {
        if (_stringAnalyser == null && _fileManager.IsFileOpened())
        {
            _stringAnalyser = new StringAnalyser(_fileManager.WinFile);
            _filterChanged = true;
            LoadStringsAsync();
        }
        else
        {
            //TODO Dialog file not loaded
        }
    }

    public async void LoadStringsAsync()
    {
        if (!_filterChanged) return;

        Loading = true;
        StringsCollection = await Task.Run(() =>
        {
            var observableCollection = new ObservableCollection<GroupedList>();
            foreach (var keyValuePair in _stringAnalyser.GetStrings(new StringFilter((int)MinLength, (int)MaxLength, Search)))
            {
                observableCollection.Add(new GroupedList(keyValuePair.Value) { Key = keyValuePair.Key });
            }
            return observableCollection;
        });
        Loading = false;
        _filterChanged = false;
    }

    private bool SetFilterProperty<T>([NotNullIfNotNull("newValue")] ref T field, T newValue, [CallerMemberName] string propertyName = null)
    {
        _filterChanged = true;
        return SetProperty(ref field, newValue, propertyName);
    }

    protected bool SetProperty<T>(Config<T> config, T value, [CallerMemberName] string propertyName = null)
    {
        // We duplicate the code here instead of calling the overload because we can't
        // guarantee that the invoked SetProperty<T> will be inlined, and we need the JIT
        // to be able to see the full EqualityComparer<T>.Default.Equals call, so that
        // it'll use the intrinsics version of it and just replace the whole invocation
        // with a direct comparison when possible (eg. for primitive numeric types).
        // This is the fastest SetProperty<T> overload so we particularly care about
        // the codegen quality here, and the code is small and simple enough so that
        // duplicating it still doesn't make the whole class harder to maintain.
        _filterChanged = true;
        
        OnPropertyChanging(propertyName);

        _configProvider.SetConfig(config, value);

        OnPropertyChanged(propertyName);

        return true;
    }    

    private void WinFileManager_WinFileClosed(object sender, WinFileClosedEventArgs e)
    {
        _stringAnalyser = null;
        StringsCollection = null;
    }
}
