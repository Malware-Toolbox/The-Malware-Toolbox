using System.Collections.Generic;
using System.Collections.ObjectModel;
using MalwareToolbox.DesktopApp.Core.Processes;
using MalwareToolbox.LibraryC.ProcessAnalysis;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools.Process;

public class ThreadsViewModel : ToolboxViewModel
{
    private IProcess _process;
    private ObservableCollection<IThread> _threadList;

    public IProcess Process
    {
        get => _process;
        set => SetProperty(ref _process, value);
    }

    public ObservableCollection<IThread> ThreadList
    {
        get => _threadList;
        set => SetProperty(ref _threadList, value);
    }

    public ThreadsViewModel()
    {
        ThreadList = new ObservableCollection<IThread>();
    }

    public void InitThreadLoop()
    {
        ProcessManager.ProcessUpdate += UpdateThreadList;
        Process.DoThreadsLoad = true;
    }

    public void StopThreadLoop()
    {
        ProcessManager.ProcessUpdate -= UpdateThreadList;
        Process.DoThreadsLoad = false;
    }

    private void UpdateThreadList(object sender, ProcessUpdateEventArgs args)
    {
        var threads = args.Processes[Process.ProcessID].Threads;
        if (threads == null) return;

        HashSet<uint> newIds = new HashSet<uint>(threads.Keys);
        List<int> oldIndex = new List<int>();

        for (var i = 0; i < ThreadList.Count; i++)
        {
            if (newIds.Contains(ThreadList[i].ThreadID))
            {
                newIds.Remove(ThreadList[i].ThreadID);
            }
            else
            {
                oldIndex.Add(i);
            }
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() =>
        {
            int offset = 0;
            foreach (var i in oldIndex)
            {
                ThreadList.RemoveAt(i - (offset++));
            }

            foreach (var newId in newIds)
            {
                ThreadList.Add(threads.GetValueOrDefault(newId));
            }
        });
    }
}
