using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using CommunityToolkit.WinUI.UI;
using MalwareToolbox.DesktopApp.Core.Processes;
using MalwareToolbox.LibraryC.ProcessAnalysis;

namespace MalwareToolbox.DesktopApp.ViewModels.Tools.Process;

public class ThreadsViewModel : ToolboxViewModel
{
    private IProcess _process;

    public IProcess Process
    {
        get => _process;
        set => SetProperty(ref _process, value);
    }

    public AdvancedCollectionView ThreadList { get;  }

    public ThreadsViewModel()
    {
        ThreadList = new AdvancedCollectionView(new ObservableCollection<IThread>());
    }

    public void InitThreadLoop()
    {
        ProcessManager.ProcessUpdate += UpdateThreadList;
        Process.DoThreadsLoad = true;
    }

    public void StopThreadLoop()
    {
        ProcessManager.ProcessUpdate -= UpdateThreadList;
        Process.DoThreadsLoad = false;
    }

    private void UpdateThreadList(object sender, ProcessUpdateEventArgs args)
    {
        var threads = args.Processes.GetValueOrDefault(Process.ProcessID)?.Threads;
        if (threads == null) return;

        HashSet<uint> newIds = new HashSet<uint>(threads.Keys);
        List<IThread> oldThreads = new List<IThread>();

        foreach (var item in ThreadList.Source)
        {
            if (item is not IThread thread) continue;

            if (newIds.Contains(thread.ThreadID))
            {
                newIds.Remove(thread.ThreadID);
            }
            else
            {
                oldThreads.Add(thread);
            }
        }

        ThreadHelper.DispatcherQueue.TryEnqueue(() =>
        {
            try
            {
                foreach (var thread in oldThreads)
                {
                    ThreadList.Remove(thread);
                }
            }
            catch (ArgumentOutOfRangeException)
            {
                //bug https://github.com/CommunityToolkit/WindowsCommunityToolkit/issues/4263
            }

            foreach (var newId in newIds)
            {
                ThreadList.Add(threads.GetValueOrDefault(newId));
            }
        });
    }
}
