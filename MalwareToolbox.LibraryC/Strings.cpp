#include "pch.h"
#include "Strings.h"
#include "Utils.h"

#include <ctype.h>
#include <iostream>
#include <regex>

using namespace std;
using namespace System::Text;
using namespace MalwareToolbox::LibraryC::Strings;
using namespace MalwareToolbox::LibraryC::Utils;

StringCategoriser::StringCategoriser()
{
	m_exact_match_map = gcnew Dictionary<String^, String^>();
	m_regex_match_list = gcnew List<Tuple<String^, Regex^>^>();
	m_custom_match_list = gcnew List<StringCategoryMatcher^>();
	AddDefaultMatches();
}

void StringCategoriser::AddDefaultMatches()
{
	AddExactMatch("DOS header", "!This program cannot be run in DOS mode.");
	AddExactMatch("PE header", "MZ");

	AddRegexMatch("URL", "\\b((?:https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:, .;]*[-a-zA-Z0-9+&@#/%=~_|])");
	AddRegexMatch("IPv4", "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])");
	AddRegexMatch("IPv6", "((([0-9a-fA-F]){1,4})\\:){7}([0-9a-fA-F]){1,4}");
	AddRegexMatch("DLL", "(?i)[a-zA-Z0-9-_]*\.dll");
}

void StringCategoriser::AddExactMatch(String^ categoryName, String^ matchString)
{
	m_exact_match_map->TryAdd(matchString, categoryName);
}

void StringCategoriser::AddRegexMatch(String^ categoryName, String^ matchRegex)
{
	m_regex_match_list->Add(gcnew Tuple<String^, Regex^>(categoryName, gcnew Regex(matchRegex)));
}

void StringCategoriser::AddCustomMatch(StringCategoryMatcher^ customMatcher)
{
	m_custom_match_list->Add(customMatcher);
}

Dictionary<String^, List<String^>^>^ StringCategoriser::CategoriseStrings(List<String^>^ strings)
{
	Dictionary<String^, List<String^>^>^ categorised_strings = gcnew Dictionary<String^, List<String^>^>();
	for each (String^ str in strings)
	{
		String^ category = GetCategory(str);

		List<String^>^ strings_list;
		if (!categorised_strings->TryGetValue(category, strings_list))
		{
			strings_list = gcnew List<String^>();
			categorised_strings->Add(category, strings_list);
		}
		strings_list->Add(str);
	}
	return categorised_strings;
}

String^ StringCategoriser::GetCategory(String^ str)
{
	str = str->Trim();
	
	String^ category = nullptr;
	m_exact_match_map->TryGetValue(str, category);
	if (category != nullptr) return category;

	for each (Tuple<String^, Regex^>^ regex_match in m_regex_match_list)
	{
		if (regex_match->Item2->IsMatch(str))
		{
			return regex_match->Item1;
		}
	}

	for each (StringCategoryMatcher^ custom_match in m_custom_match_list)
	{
		String^ category = custom_match->Invoke(str);
		if (category != nullptr) return category;
	}

	return "Unknown";
}

StringAnalyser::StringAnalyser(WinFile^ file)
	: m_file(file)
{
}

void StringAnalyser::GenerateStrings()
{
	m_strings = gcnew List<StringItem^>();
	string str = "";
	for (DWORD i = 0; i < m_file->Size; i++)
	{
		if (isprint(m_file->Data[i]))
		{
			str += static_cast<char>(m_file->Data[i]);
		}
		else
		{
			String^ str_cs = gcnew String(str.c_str());
			m_strings->Add(gcnew StringItem(m_categoriser.GetCategory(str_cs), str_cs));
			str = "";
		}
	}
}

Dictionary<String^, List<String^>^>^ StringAnalyser::GetStrings(StringFilter^ filter)
{
	if (m_strings == nullptr) GenerateStrings();

	Dictionary<String^, List<String^>^>^ categorised_strings = gcnew Dictionary<String^, List<String^>^>();
	for each (auto string_item in m_strings)
	{
		if (string_item->Value->Length < filter->MinLength) continue;
		if (string_item->Value->Length > filter->MaxLength) continue;
		if (filter->Search != nullptr && 
			!string_item->Category->Equals(filter->Search) && 
			!string_item->Value->Contains(filter->Search)) continue;

		List<String^>^ strings_list;
		if (!categorised_strings->TryGetValue(string_item->Category, strings_list))
		{
			strings_list = gcnew List<String^>();
			categorised_strings->Add(string_item->Category, strings_list);
		}
		strings_list->Add(string_item->Value);
	}

	return categorised_strings;
}
