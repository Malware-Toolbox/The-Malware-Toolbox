#include "pch.h"
#include "Strings.h"
#include "Utils.h"

#include <ctype.h>
#include <iostream>
#include <regex>

using namespace std;
using namespace System::Text;
using namespace MalwareToolbox::LibraryC::Strings;
using namespace MalwareToolbox::LibraryC::Utils;

StringCategoriser::StringCategoriser()
{
	m_exact_match_map = gcnew Dictionary<String^, String^>();
	m_regex_match_list = gcnew List<Tuple<String^, Regex^>^>();
	m_custom_match_list = gcnew List<StringCategoryMatcher^>();
	AddDefaultMatches();
}

void StringCategoriser::AddDefaultMatches()
{
	AddExactMatch("DOS header", "!This program cannot be run in DOS mode.");
	AddExactMatch("PE header", "MZ");

	AddRegexMatch("URL", "\\b((?:https?|ftp|file)://[-a-zA-Z0-9+&@#/%?=~_|!:, .;]*[-a-zA-Z0-9+&@#/%=~_|])");
	AddRegexMatch("IPv4", "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])");
	AddRegexMatch("IPv6", "((([0-9a-fA-F]){1,4})\\:){7}([0-9a-fA-F]){1,4}");
	AddRegexMatch("DLL", "(?i)[a-zA-Z0-9-_]*\.dll");
}

void StringCategoriser::AddExactMatch(String^ categoryName, String^ matchString)
{
	m_exact_match_map->TryAdd(matchString, categoryName);
}

void StringCategoriser::AddRegexMatch(String^ categoryName, String^ matchRegex)
{
	m_regex_match_list->Add(gcnew Tuple<String^, Regex^>(categoryName, gcnew Regex(matchRegex)));
}

void StringCategoriser::AddCustomMatch(StringCategoryMatcher^ customMatcher)
{
	m_custom_match_list->Add(customMatcher);
}

Dictionary<String^, List<String^>^>^ StringCategoriser::CategoriseStrings(List<String^>^ strings)
{
	Dictionary<String^, List<String^>^>^ categorized_strings = gcnew Dictionary<String^, List<String^>^>();
	for each (String^ str in strings)
	{
		String^ category = GetCategory(str);

		List<String^>^ strings_list;
		if (!categorized_strings->TryGetValue(category, strings_list))
		{
			strings_list = gcnew List<String^>();
			categorized_strings->Add(category, strings_list);
		}
		strings_list->Add(str);
	}
	return categorized_strings;
}

String^ StringCategoriser::GetCategory(String^ str)
{
	str = str->Trim();
	
	String^ category = nullptr;
	m_exact_match_map->TryGetValue(str, category);
	if (category != nullptr) return category;

	for each (Tuple<String^, Regex^>^ regex_match in m_regex_match_list)
	{
		if (regex_match->Item2->IsMatch(str))
		{
			return regex_match->Item1;
		}
	}

	for each (StringCategoryMatcher^ custom_match in m_custom_match_list)
	{
		String^ category = custom_match->Invoke(str);
		if (category != nullptr) return category;
	}

	return "Unknown";
}

StringAnalyser::StringAnalyser(Utils::WinFile^ file) : m_file(file)
{
}

List<String^>^ StringAnalyser::GenerateStrings(int minLength, int maxLength)
{
	List<String^>^ strings = gcnew List<String^>();
	string str = "";
	for (DWORD i = 0; i < m_file->Size; i++)
	{
		if (isprint(m_file->Data[i]))
		{
			str += static_cast<char>(m_file->Data[i]);
		}
		else
		{
			if (str.size() >= minLength || str.size() >= maxLength)
			{
				strings->Add(gcnew String(str.c_str()));
			}
			str = "";
		}
	}

	return strings;
}
