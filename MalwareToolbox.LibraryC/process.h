#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <processthreadsapi.h>
#define ARRAY_SIZE 1024
#include <winver.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <time.h>
#include <crtdbg.h>
#include <atlstr.h>
#include "thread.h"
#include <vector>
#include "performance.h"
#include "security.h"

// Main: Initalise all processes into a process class that is stored in a process[], Use processID 
// Store one process object that contains Process Name, ProcessID

              //Working set, Description Company Name
namespace MalwareToolbox {
    namespace LibraryC {
        namespace ProcessAnalysis {

        
            public ref class Process

            {
            public:

                //driversinfo();
                //systeminfo();
                //list_processes();
                DWORD ProcessID; // Unique Identifier for process
                LPWSTR ProcessName;
                LPWSTR ProcessPath;
                wchar_t* Description;
                std::vector<Thread> ThreadArray;
                Performance performance;
                Security security;

                Process() {
                    ProcessID = NULL;
                    ProcessName = NULL;
                    ProcessPath = NULL;
                }
                
                int main() 
                {
                    // Get list of Process Identifiers 
                    DWORD allProcesses[1024], cbNeeded, cProcesses;
                    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded)) {
                        return 1;
                    }
                    // Calc number of processes 
                    cProcesses = cbNeeded / sizeof(DWORD);
                    Process* processArray;
                    processArray = new Process[cProcesses];
                    // Print process info 
                    for (int i = 0; i < cProcesses; i++) {
                        Process p;
                        Thread t;
                        if (allProcesses[i] != 0) {
                            HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, allProcesses[i]); //try get openprocess in a void func then use that value to iniialise class
                            p.Initalise(hProcess, allProcesses[i]);
                            processArray[i] = p;
                            while (true) {
                                int x = t.EnumerateThreads(allProcesses[i]);
                                t.Initalise();
                                p.AddThread(t);
                                if (x == 0) {
                                    break;
                                }
                            }
                            CloseHandle(hProcess);
                        }
                    }
                    for (int i = 0; i < cProcesses; i++) {
                        processArray[i].PrintAll();
                    }
                }

                void Initalise(HANDLE hProcess, DWORD processID) //psapi.h 
                {

                    ProcessID = processID;
                    //std::wcout << ProcessID << L"\n";

                    if (hProcess != NULL) {

                        //performance.InitaliseAll(hProcess, processID);
                        security.Initalise(hProcess);

                        // Get Process Name 
                        HMODULE hMod;
                        DWORD cbNeeded;
                        //TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");
                        LPWSTR szProcessName = new TCHAR[MAX_PATH];
                        if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
                        {
                            GetModuleBaseName(hProcess, hMod, szProcessName, MAX_PATH);
                            ProcessName = szProcessName;
                            //std::wcout << ProcessName << L"\n";
                            //std::wcout << "ProcessID ProcessClass " <<ProcessID << L"\n";


                            //Get executable path of process
                            LPWSTR lpImageFileName = new TCHAR[MAX_PATH];
                            if ((GetProcessImageFileNameW(hProcess, lpImageFileName, MAX_PATH) != 0)) {
                                //std::wcout << lpImageFileName << L"\n";
                                ProcessPath = lpImageFileName;
                            }
                            else {
                                //std::cout << GetLastError() << "\n"; For troubleshooting 
                            }
                            // End of Executable path of process
            // 
            // 
            // 
                                 // Get File Descriptions 
                            TCHAR fileName[MAX_PATH];
                            GetModuleFileNameExW(hProcess, hMod, fileName, MAX_PATH);
                            int dwLen = GetFileVersionInfoSize(fileName, NULL);
                            if (!dwLen)
                                std::cout << "0"; // return 0

                            auto* sKey = new BYTE[dwLen];
                            std::unique_ptr<BYTE[]> skey_automatic_cleanup(sKey);
                            if (!GetFileVersionInfo(fileName, NULL, dwLen, sKey))
                                std::cout << "0"; // return 0

                            struct LANGANDCODEPAGE {
                                WORD wLanguage;
                                WORD wCodePage;
                            } *lpTranslate;

                            UINT cbTranslate = 0;
                            if (!VerQueryValue(sKey, L"\\VarFileInfo\\Translation",
                                (LPVOID*)&lpTranslate, &cbTranslate))
                                std::cout << "0"; // return 0

                            for (unsigned int i = 0; i < (cbTranslate / sizeof(LANGANDCODEPAGE)); i++)
                            {
                                WCHAR subblock[256];
                                //use sprintf if sprintf_s is not available
                                swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription",
                                    lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);
                                wchar_t* description = NULL;
                                UINT dwBytes;
                                if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes)) {
                                    //std::wcout << description << "\n";
                                    if (dwBytes != 0) {


                                        Description = new wchar_t[dwBytes];
                                        wcscpy_s(Description, dwBytes, description);
                                        //std::wcout << Description << L"\n";
                                    }
                                }


                            }


                            //VerQueryValueW(lpData, TEXT("\\VarFileInfo\\Translation"), (LPVOID*)&lpTranslate, puLen);
                        }
                        //End Get Process Name 

                        //Get executable path of process
                        LPWSTR lpImageFileName = new TCHAR[MAX_PATH];
                        if ((GetProcessImageFileNameW(hProcess, lpImageFileName, MAX_PATH) != 0)) {
                            //std::wcout << lpImageFileName << L"\n";
                            //ProcessPath = lpImageFileName;
                        }
                        else {
                            //std::cout << GetLastError() << "\n"; For troubleshooting 
                        }
                        // End of Executable path of process


                        // lpbaseofdll = load address of the module ,sizeofimage = size of the linear space that the module occupies, entrypoint of the module 


                        //GetProcessTimes(hProcess,lpCreationTime,lpExitTime,lpKernelTime,lpUserTime); //FileTime structure, minwinbase.h

                    }
                    else {
                        //std::cout << "ERROR \n"; //Some processes have no handle
                    }




                    //
                }
                void PrintAll() {
                    if (ProcessName != NULL) {

                        //std::cout << "Test" << "\n";
                        //wprintf((L"%s \n"), ProcessName);
                        std::wcout << ProcessName << L"\n";
                        std::wcout << ProcessID << L"\n";
                        std::wcout << ProcessPath << L"\n";
                        if (Description != NULL)
                            std::wcout << Description << L"\n";
                        for (auto itr : ThreadArray)
                            ThreadArray[itr].PrintAll();
                        performance.PrintAll();
                        //security.PrintAll();
                    }
                    else {
                        //std::cout << "BEN\n";
                    }
                }
                void AddThread(Thread t) {
                    ThreadArray.push_back(t);
                }
                void PrintThreads() { // Get Thread Name and details 
                    std::cout << "Process ID " << ProcessID << "\n";
                    for (Thread i : ThreadArray) {
                        std::cout << "ThreadID = " << i.ThreadID << std::endl;
                    }
                }
            };
        }
    }
}