#include "pch.h"
#include "Utils.h"

using namespace MalwareToolbox::LibraryC::Utils;
using namespace Runtime::InteropServices;

LPSTR Converters::string_to_lpstr(String^ value)
{
	return static_cast<LPSTR>(Marshal::StringToHGlobalAnsi(value).ToPointer());
}

LPWSTR Converters::string_to_lpwstr(String^ value)
{
	return static_cast<LPWSTR>(Marshal::StringToHGlobalUni(value).ToPointer());
}


unsigned char* Converters::bytearray_to_char(array<Byte>^ value)
{
	const pin_ptr<Byte> p = &value[0];
	return p;
}

DWORD Converters::uchar_to_int32(unsigned char* value)
{
	return static_cast<DWORD>(value[3]) << 24 |
		static_cast<DWORD>(value[2]) << 16 |
		static_cast<DWORD>(value[1]) << 8 |
		static_cast<DWORD>(value[0]);
}

DWORD Converters::uchar_to_int32_bigendian(unsigned char* value)
{
	return static_cast<DWORD>(value[0]) << 24 |
		static_cast<DWORD>(value[1]) << 16 |
		static_cast<DWORD>(value[2]) << 8 |
		static_cast<DWORD>(value[3]);
}

DWORD64 Converters::uchar_to_int64(unsigned char* value)
{
	return static_cast<DWORD64>(value[7]) << 56 |
		static_cast<DWORD64>(value[6]) << 48 |
		static_cast<DWORD64>(value[5]) << 40 |
		static_cast<DWORD64>(value[4]) << 32 |
		static_cast<DWORD64>(value[3]) << 24 |
		static_cast<DWORD64>(value[2]) << 16 |
		static_cast<DWORD64>(value[1]) << 8 |
		static_cast<DWORD64>(value[0]);
}

DWORD64 Converters::uchar_to_int64_bigendian(unsigned char* value)
{
	return static_cast<DWORD64>(value[0]) << 56 |
		static_cast<DWORD64>(value[1]) << 48 |
		static_cast<DWORD64>(value[2]) << 40 |
		static_cast<DWORD64>(value[3]) << 32 |
		static_cast<DWORD64>(value[4]) << 24 |
		static_cast<DWORD64>(value[5]) << 16 |
		static_cast<DWORD64>(value[6]) << 8 |
		static_cast<DWORD64>(value[7]);
}

String^ Converters::uchar_to_string(unsigned char* value)
{
	return gcnew String(reinterpret_cast<char*>(value));
}

String^ Converters::uchar_to_string(unsigned char* value, int length)
{
	return gcnew String(reinterpret_cast<char*>(value), 0, length > 0 ? length : 0);
}

String^ Converters::uchar_to_string_w(unsigned char* value)
{
	return gcnew String(reinterpret_cast<wchar_t*>(value));
}

String^ Converters::uchar_to_string_w(unsigned char* value, int length)
{
	return gcnew String(reinterpret_cast<wchar_t*>(value), 0, length > 0 ? length : 0);
}

array<BYTE>^ Converters::uchar_to_bytearray(unsigned char* value, int size)
{
	array<BYTE>^ byte_array = gcnew array<BYTE>(size);
	Marshal::Copy(safe_cast<IntPtr>(value), byte_array, 0, size);
	return byte_array;
}

DWORD64 Converters::twoint32_to_int64(DWORD value1, DWORD value2)
{
	return static_cast<DWORD64>(value1) << 32 |
		static_cast<DWORD64>(value2);
}

String^ Converters::sidtype_tostring(SID_NAME_USE value)
{
	switch (value) {
		case SidTypeAlias:
			return "Alias";
		case SidTypeComputer:
			return "Computer";
		case SidTypeDeletedAccount:
			return "Deleted Account";
		case SidTypeDomain:
			return "Domain";
		case SidTypeGroup:
			return "Group";
		case SidTypeInvalid:
			return "Invalid";
		case SidTypeLabel:
			return "Label";
		case SidTypeLogonSession:
			return "Logon Session";
		case SidTypeUnknown:
			return "Unknown";
		case SidTypeUser:
			return "User";
		case SidTypeWellKnownGroup:
			return "Well Known Group";
		default:
			return "N/A";
	}
}

String^ Converters::tokentype_tostring(TOKEN_TYPE value)
{
	switch (value) {
		case TokenPrimary:
			return "Primary";
		case TokenImpersonation:
			return "Impersonation";
		default:
			return "N/A";
	}
}

String^ Converters::sectype_tostring(SECURITY_IMPERSONATION_LEVEL value)
{
	switch (value) {
		case SecurityAnonymous:
			return "Anonymous";
		case SecurityIdentification:
			return "Identification";
		case SecurityImpersonation:
			return "Impersonation";
		case SecurityDelegation:
			return "Delegation";
		default:
			return "N/A";
	}
}

String^ Converters::elevationtype_tostring(TOKEN_ELEVATION_TYPE value)
{
	switch (value) {
		case TokenElevationTypeDefault:
			return "Default";
		case TokenElevationTypeFull:
			return "Full";
		case TokenElevationTypeLimited:
			return "Limited";
		default:
			return "N/A";
	}
}
