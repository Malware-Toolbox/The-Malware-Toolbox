#include "pch.h"
#include "Dynamic.h"
#include "Utils.h"

#include <iostream>
#include <phnt_windows.h>

using namespace System;
using namespace Collections::Generic;
using namespace MalwareToolbox::LibraryC::Dynamic;
using namespace MalwareToolbox::LibraryC::Utils;

void GenerateRegData(HKEY key, LPCWSTR sub_key, RegistryKey^ reg)
{
    DWORD result = NULL;

    result = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        sub_key,
        0,
        KEY_READ,
        &key
    );

    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error opening key " << sub_key << std::endl;
        return;
    }

    DWORD lpcSubKeys = NULL;
    DWORD lpcbMaxSubKeyLen = NULL;
    DWORD lpcbMaxClassLen = NULL;
    DWORD lpcValues = NULL;
    DWORD lpcbMaxValueNameLen = NULL;
    DWORD lpcbMaxValueLen = NULL;
    DWORD lpcbSecurityDescriptor = NULL;

    RegQueryInfoKey(key, NULL, NULL, NULL, &lpcSubKeys, &lpcbMaxSubKeyLen, &lpcbMaxClassLen, &lpcValues, &lpcbMaxValueNameLen, &lpcbMaxValueLen, &lpcbSecurityDescriptor, NULL);
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error getting key info" << std::endl;
        return;
    }

    std::cout << lpcSubKeys << std::endl;
    std::cout << lpcbMaxSubKeyLen << std::endl;
    std::cout << lpcbMaxClassLen << std::endl;
    std::cout << lpcValues << std::endl;
    std::cout << lpcbMaxValueNameLen << std::endl;
    std::cout << lpcbMaxValueLen << std::endl;
    std::cout << lpcbSecurityDescriptor << std::endl;
    std::cout << std::endl;

    DWORD sindex = 0;

    while (true)
    {
        LPWSTR sname = new WCHAR[lpcbMaxSubKeyLen];
        DWORD sname_size = sizeof(sname);
        result = RegEnumKeyEx(key, sindex++, sname, &sname_size, NULL, NULL, NULL, NULL);
        // std::cout << result << std::endl;
        if (result != ERROR_SUCCESS)
        {
            break;
        }
        std::cout << "-----------SUB KEY-----------" << std::endl;
        std::wcout << sname << std::endl;
        // std::cout << sname_size << std::endl;
        std::cout << std::endl;

        HKEY vkey = nullptr;
        result = RegOpenKeyEx(
            key,
            sname,
            0,
            KEY_READ,
            &vkey
        );
        if (result != ERROR_SUCCESS)
        {
            std::cout << "Error opening key " << sname << std::endl;
            return;
        }

        RegistryKey^ reg_key = {};
        reg_key->Name = gcnew String(sname);
        GenerateRegData(vkey, sname, reg_key);
    }

    DWORD vindex = 0;
    reg->Values = gcnew List<RegistryValue^>();

    std::cout << "-----VALUES-----" << std::endl;
    while (true)
    {
        LPWSTR name = new WCHAR[lpcbMaxValueNameLen];
        DWORD name_size = sizeof(name);
        DWORD type = NULL;
        BYTE data[100000];
        DWORD data_size = 100000;

        // std::cout << vindex << std::endl;
        result = RegEnumValue(key, vindex++, name, &name_size, NULL, &type, data, &data_size);
        // std::cout << result << std::endl;
        if (result != ERROR_SUCCESS)
        {
            break;
        }

        RegistryValue^ value = {};

        value->Name = gcnew String(name);
        value->Data = Converters::cs_char_to_bytearray(data);
        value->Type = type;

        reg->Values->Add(value);

        std::wcout << name << std::endl;
        std::cout << name_size << std::endl;
        std::cout << type << std::endl;
        for (int c = 0; c < data_size; c++)
        {
            std::cout << data[c];
        }
        std::cout << data_size << std::endl;
        std::cout << std::endl;
    }
}

void RegShot::TakeSnapshot()
{
    RegistryKey^ reg = {};
    GenerateRegData(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows", reg);
    return;

	HKEY key = nullptr;
	DWORD result = NULL;
    const LPCWSTR sub_key = L"Software\\Microsoft\\Windows";

    result = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        sub_key,
        0,
        KEY_READ,
        &key
    );
    if (result != ERROR_SUCCESS)
	{
        std::cout << "Error opening key " << sub_key << std::endl;
		return;
	}

    DWORD lpcSubKeys = NULL;
    DWORD lpcbMaxSubKeyLen = NULL;
    DWORD lpcbMaxClassLen = NULL;
    DWORD lpcValues = NULL;
    DWORD lpcbMaxValueNameLen = NULL;
    DWORD lpcbMaxValueLen = NULL;
    DWORD lpcbSecurityDescriptor = NULL;

    RegQueryInfoKey(key, NULL, NULL, NULL, &lpcSubKeys, &lpcbMaxSubKeyLen, &lpcbMaxClassLen, &lpcValues, &lpcbMaxValueNameLen, &lpcbMaxValueLen, &lpcbSecurityDescriptor, NULL);
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error getting key info" << std::endl;
        return;
    }

    std::cout << lpcSubKeys << std::endl;
    std::cout << lpcbMaxSubKeyLen << std::endl;
    std::cout << lpcbMaxClassLen << std::endl;
    std::cout << lpcValues << std::endl;
    std::cout << lpcbMaxValueNameLen << std::endl;
    std::cout << lpcbMaxValueLen << std::endl;
    std::cout << lpcbSecurityDescriptor << std::endl;
    std::cout << std::endl;

    DWORD sindex = 0;

    while (true)
    {
        WCHAR sname[16383];
        DWORD sname_size = 16383;
        result = RegEnumKeyEx(key, sindex++, sname, &sname_size, NULL, NULL, NULL, NULL);
        // std::cout << result << std::endl;
        if (result != ERROR_SUCCESS)
        {
            break;
        }
        std::cout << "-----------SUB KEY-----------" << std::endl;
        std::wcout << sname << std::endl;
        // std::cout << name_size << std::endl;
        std::cout << std::endl;

        HKEY vkey = nullptr;
        result = RegOpenKeyEx(
            key,
            sname,
            0,
            KEY_READ,
            &vkey
        );
        if (result != ERROR_SUCCESS)
        {
            std::cout << "Error opening key " << sname << std::endl;
            return;
        }
        
        DWORD vindex = 0;

        std::cout << "-----VALUES-----" << std::endl;
        while (true)
        {
            WCHAR name[16383];
            DWORD name_size = 16383;
            DWORD type = NULL;
            BYTE data[100000];
            DWORD data_size = 100000;

            // std::cout << vindex << std::endl;
            result = RegEnumValue(vkey, vindex++, name, &name_size, NULL, &type, data, &data_size);
            // std::cout << result << std::endl;
            if (result != ERROR_SUCCESS)
            {
                break;
            }
            std::wcout << name << std::endl;
            std::cout << name_size << std::endl;
            std::cout << type << std::endl;
            for (int c = 0; c < data_size; c++)
            {
                std::cout << data[c];
            }
            std::cout << data_size << std::endl;
            std::cout << std::endl;
        }
    }
}
