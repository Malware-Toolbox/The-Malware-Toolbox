#include "pch.h"
#include "Dynamic.h"
#include "Utils.h"

#include <iostream>
#include <phnt_windows.h>

using namespace System;
using namespace Collections::Generic;
using namespace MalwareToolbox::LibraryC::Dynamic;
using namespace MalwareToolbox::LibraryC::Utils;

void GenerateRegData(HKEY parent_key, LPWSTR key_name, RegistryKey^ reg_key)
{
    DWORD result;
    HKEY key = nullptr;

    result = RegOpenKeyEx(
        parent_key,
        key_name,
        0,
        KEY_READ,
        &key
    );
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error opening key: " << result << " : " << key_name << std::endl;
        return;
    }

    DWORD sub_keys_count;
    DWORD max_sub_key_name_size;
    DWORD max_class_size;
    DWORD values_count;
    DWORD max_value_name_size;
    DWORD max_value_data_size;
    DWORD security_descriptor_size;

    RegQueryInfoKey(
        key,
        nullptr,
        nullptr,
        nullptr, 
        &sub_keys_count, 
        &max_sub_key_name_size,
        &max_class_size,
        &values_count, 
        &max_value_name_size, 
        &max_value_data_size, 
        &security_descriptor_size,
        nullptr
    );
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error getting key info: " << result << std::endl;
        return;
    }

    // Increment size by one to include the null terminator
    max_sub_key_name_size++;
    max_value_name_size++;
    max_value_data_size++;

    RegistryKeyMeta^ meta_data = gcnew RegistryKeyMeta();

    meta_data->SubKeysCount = sub_keys_count;
    meta_data->MaxSubKeyNameSize = max_sub_key_name_size;
    meta_data->MaxClassSize = max_class_size;
    meta_data->ValuesCount = values_count;
    meta_data->MaxValueNameSize = max_value_name_size;
    meta_data->MaxValueDataSize = max_value_data_size;
    meta_data->SecurityDescriptorSize = security_descriptor_size;

    reg_key->Meta = meta_data;

    //TODO check for SubKeysCount > 0
    DWORD sindex = 0;
    reg_key->SubKeys = gcnew List<RegistryKey^>(sub_keys_count);

    while (true)
    {
	    const LPWSTR sub_key_name = new WCHAR[max_sub_key_name_size];
        DWORD sub_key_name_size = max_sub_key_name_size;
        result = RegEnumKeyEx(
            key, 
            sindex++, 
            sub_key_name,
            &sub_key_name_size,
            nullptr,
            nullptr, 
            nullptr,
            nullptr
        );
        if (result != ERROR_SUCCESS)
        {
            if (result != ERROR_NO_MORE_ITEMS) std::cout << "Error getting sub key: " << result << std::endl;
            break;
        }

        RegistryKey^ sub_reg_key = gcnew RegistryKey();

        sub_reg_key->ParentKey = reg_key;
    	sub_reg_key->Name = gcnew String(sub_key_name);

    	GenerateRegData(key, sub_key_name, sub_reg_key);

    	reg_key->SubKeys->Add(sub_reg_key);

        delete[] sub_key_name;
    }

    //TODO Check for ValuesCount > 0
    DWORD vindex = 0;
    reg_key->Values = gcnew List<RegistryValue^>(values_count);

    while (true)
    {
	    const LPWSTR value_name = new WCHAR[max_value_name_size];
        DWORD value_name_size = max_value_name_size;
        DWORD type;
	    const LPBYTE data = new BYTE[max_value_data_size];
        DWORD data_size = max_value_data_size;

        result = RegEnumValue(
            key, 
            vindex++,
            value_name, 
            &value_name_size, 
            NULL,
            &type,
            data,
            &data_size
        );
        if (result != ERROR_SUCCESS)
        {
            if (result != ERROR_NO_MORE_ITEMS) std::wcout << "Error getting value: " << result << value_name_size << std::endl;
            break;
        }

        RegistryValue^ value = gcnew RegistryValue();

        value->Name = gcnew String(value_name);
        value->Type = type;
        value->Data = Converters::cs_char_to_bytearray(data, data_size);

        reg_key->Values->Add(value);

        delete[] value_name;
        delete[] data;
    }
}

RegistryKey^ RegShot::TakeSnapshot()
{
    RegistryKey^ reg = gcnew RegistryKey();
    GenerateRegData(HKEY_CLASSES_ROOT, nullptr, reg);
    return reg;
}
