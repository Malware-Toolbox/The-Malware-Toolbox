#include "pch.h"
#include "Dynamic.h"
#include "Utils.h"

#include <iostream>
#include <phnt_windows.h>

using namespace System;
using namespace Collections::Generic;
using namespace MalwareToolbox::LibraryC::Dynamic;
using namespace MalwareToolbox::LibraryC::Utils;

void GenerateRegData(HKEY parent_key, LPWSTR key_name, RegistryKey^ reg_key)
{
    DWORD result;
    HKEY key = nullptr;

    result = RegOpenKeyEx(
        parent_key,
        key_name,
        0,
        KEY_READ,
        &key
    );
    if (result != ERROR_SUCCESS)
    {
        std::wcout << "Error opening key: " << result << " : " << key_name << std::endl;
        return;
    }

    DWORD sub_keys_count;
    DWORD max_sub_key_name_size;
    DWORD max_class_size;
    DWORD values_count;
    DWORD max_value_name_size;
    DWORD max_value_data_size;
    DWORD security_descriptor_size;

    RegQueryInfoKey(
        key,
        nullptr,
        nullptr,
        nullptr, 
        &sub_keys_count, 
        &max_sub_key_name_size,
        &max_class_size,
        &values_count, 
        &max_value_name_size, 
        &max_value_data_size, 
        &security_descriptor_size,
        nullptr
    );
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error getting key info: " << result << std::endl;
        return;
    }

    // Increment size by one to include the null terminator
    max_sub_key_name_size++;
    max_value_name_size++;
    max_value_data_size++;

    RegistryKeyMeta^ meta_data = gcnew RegistryKeyMeta();

    meta_data->SubKeysCount = sub_keys_count;
    meta_data->MaxSubKeyNameSize = max_sub_key_name_size;
    meta_data->MaxClassSize = max_class_size;
    meta_data->ValuesCount = values_count;
    meta_data->MaxValueNameSize = max_value_name_size;
    meta_data->MaxValueDataSize = max_value_data_size;
    meta_data->SecurityDescriptorSize = security_descriptor_size;

    reg_key->Meta = meta_data;

    if (sub_keys_count > 0)
    {
        reg_key->SubKeys = gcnew Dictionary<String^, RegistryKey^>(sub_keys_count);

        for (DWORD sindex = 0; sindex < sub_keys_count; sindex++)
        {
            const LPWSTR sub_key_name = new WCHAR[max_sub_key_name_size];
            DWORD sub_key_name_size = max_sub_key_name_size;
            result = RegEnumKeyEx(
                key,
                sindex,
                sub_key_name,
                &sub_key_name_size,
                nullptr,
                nullptr,
                nullptr,
                nullptr
            );
            if (result != ERROR_SUCCESS)
            {
                std::cout << "Error getting sub key: " << result << std::endl;
                break;
            }

            RegistryKey^ sub_reg_key = gcnew RegistryKey();

            sub_reg_key->ParentKey = reg_key;
            sub_reg_key->Name = gcnew String(sub_key_name);

            GenerateRegData(key, sub_key_name, sub_reg_key);

            reg_key->SubKeys->TryAdd(sub_reg_key->Name, sub_reg_key);

            delete[] sub_key_name;
        }
    }

    if (values_count > 0)
    {
        reg_key->Values = gcnew Dictionary<String^, RegistryValue<Object^>^>(values_count);

        for (DWORD vindex = 0; vindex < values_count; vindex++)
        {
            const LPWSTR value_name = new WCHAR[max_value_name_size];
            DWORD value_name_size = max_value_name_size;
            DWORD type;
            const LPBYTE data = new BYTE[max_value_data_size];
            DWORD data_size = max_value_data_size;

            result = RegEnumValue(
                key,
                vindex,
                value_name,
                &value_name_size,
                NULL,
                &type,
                data,
                &data_size
            );
            if (result != ERROR_SUCCESS)
            {
                std::wcout << "Error getting value: " << result << value_name_size << std::endl;
                break;
            }

            RegistryValue<Object^>^ value = gcnew RegistryValue<Object^>();

            value->Name = gcnew String(value_name);
            value->Type = type;

            if (type == REG_SZ || type == REG_EXPAND_SZ)
            {
                value->Data = Converters::uchar_to_string_w(data, data_size / 2 - 1);
            }
            else if ((type == REG_DWORD || type == REG_DWORD_LITTLE_ENDIAN) && sizeof(DWORD) == data_size)
            {
                value->Data = Converters::uchar_to_int32(data);
            }
            else if (type == REG_DWORD_BIG_ENDIAN && sizeof(DWORD) == data_size)
            {
                value->Data = Converters::uchar_to_int32_bigendian(data);
            }
            else if ((type == REG_QWORD || type == REG_QWORD_LITTLE_ENDIAN) && sizeof(DWORD64) == data_size)
            {
                value->Data = Converters::uchar_to_int64(data);
            }
            else if (type == REG_MULTI_SZ)
            {
                String^ multi_str = Converters::uchar_to_string_w(data, data_size / 2 - 2);
                value->Data = multi_str->Split('\0');
            }
            else if (type == REG_BINARY)
            {
                value->Data = Converters::uchar_to_bytearray(data, data_size);
            }
            else if (type == REG_NONE)
            {
                value->Data = nullptr;
            }
            else
            {
	            std::cout << "Error converting type: " << type << std::endl;
                //Fallback to byte array
                value->Data = Converters::uchar_to_bytearray(data, data_size);
            }
            reg_key->Values->Add(value->Name, value);

            delete[] value_name;
            delete[] data;
        }
    }

    RegCloseKey(key);
}

RegistryKey^ RegShot::TakeSnapshot()
{
    RegistryKey^ reg_current_user = gcnew RegistryKey();
    GenerateRegData(HKEY_CURRENT_USER, nullptr, reg_current_user);
    RegistryKey^ reg_current_config = gcnew RegistryKey();
    GenerateRegData(HKEY_CURRENT_CONFIG, nullptr, reg_current_config);
    RegistryKey^ reg_local_machine = gcnew RegistryKey();
    GenerateRegData(HKEY_LOCAL_MACHINE, nullptr, reg_local_machine);
    RegistryKey^ reg_users = gcnew RegistryKey();
    GenerateRegData(HKEY_USERS, nullptr, reg_users);

    return reg_current_user;
}
