#include "pch.h"
#include "RegShot.h"
#include "Utils.h"

#include <iostream>
#include <phnt_windows.h>
#include <xlocmon>

using namespace System;
using namespace Collections::Generic;
using namespace MalwareToolbox::LibraryC::RegShot;
using namespace MalwareToolbox::LibraryC::Utils;

RegistryValue::~RegistryValue()
{
    delete Name;
    delete Data;
    Key = nullptr;
}

void RegistryValue::ParseData(DWORD type, LPBYTE data, DWORD data_size)
{
    Type = type;

    switch (type)
    {
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_LINK:
        Data = Converters::uchar_to_string_w(data, data_size / 2)->TrimEnd('\0');
        break;
    case REG_DWORD:
        Data = Converters::uchar_to_int32(data);
        break;
    case REG_DWORD_BIG_ENDIAN:
        Data = Converters::uchar_to_int32_bigendian(data);
        break;
    case REG_QWORD:
        Data = Converters::uchar_to_int64(data);
        break;
    case REG_MULTI_SZ:
    {
        String^ multi_str = Converters::uchar_to_string_w(data, data_size / 2 - 2);
        Data = multi_str->Split('\0');
        break;
    }
    default:
        // Fallback to byte array
        if (data_size == 0) Data = Array::Empty<BYTE>();
        else Data = Converters::uchar_to_bytearray(data, data_size);
    }
}

String^ RegistryValue::ToString()
{
    if (Data == nullptr) return "";

    switch (Type)
    {
    case REG_NONE:
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_LINK:
    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
    case REG_QWORD:
        return Data->ToString();
    case REG_MULTI_SZ:
        return String::Join(", ", safe_cast<array<String^>^>(Data));
    case REG_BINARY:
    default:
	    Text::StringBuilder^ builder = gcnew Text::StringBuilder();
        for each (BYTE c in safe_cast<array<BYTE>^>(Data))
        {
            builder->Append(c.ToString("X2") + " ");
        }
        return builder->ToString();
    }
}

bool RegistryValue::Equals(Object^ o)
{
    if (o == nullptr) return false;
    if (o->GetType() != this->GetType()) return false;

    RegistryValue^ other = safe_cast<RegistryValue^>(o);

    if (Type != other->Type) return false;

    switch (Type)
    {
    case REG_NONE:
        break;
    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_LINK:
    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
    case REG_QWORD:
        return Data->Equals(other->Data);
    case REG_MULTI_SZ:
        //TODO
        break;
    case REG_BINARY:
    default:
    {
        array<BYTE>^ data1 = safe_cast<array<BYTE>^>(Data);
        array<BYTE>^ data2 = safe_cast<array<BYTE>^>(other->Data);

        if (data1->Length != data2->Length) return false;

        int index = 0;
        for each (BYTE c1 in data1)
        {
            if (c1 != data2[index]) return false;
            index++;
        }
    }
    }

    return true;
}

RegistryKey::~RegistryKey()
{
    delete Name;
	delete FullPath;
    for each (auto subkey in SubKeys->Values)
    {
        delete subkey;
    }

    for each (auto value in Values->Values)
	{
		delete value;
	}
    delete SubKeys;
	delete Values;
    ParentKey = nullptr;
}

String^ RegistryValueDiff::Name::get()
{
    return Old ? Old->Name : New->Name;
}

RegistryHiveType^ RegistryHiveType::FromString(String^ hiveName)
{
    for each (RegistryHiveType^ hive_type in hive_types)
    {
	    if (hive_type->Name == hiveName)
	    {
		    return hive_type;
	    }
    }
    return nullptr;
}

IList<RegistryHiveType^>^ RegistryHiveType::GetAllTypes()
{
    return hive_types->AsReadOnly();
}

HKEY RegistryHiveType::Hkey::get()
{
    return m_hkey;
}

String^ RegistryHiveType::Name::get()
{
    return m_name;
}

RegistryHiveType::RegistryHiveType(HKEY hkey, String^ name) : m_hkey(hkey), m_name(name)
{
    if (hive_types == nullptr)
	{
		hive_types = gcnew List<RegistryHiveType^>();
	}
    hive_types->Add(this);
}

RegistrySnapshot::RegistrySnapshot(String^ name) : Name(name)
{
}

RegistrySnapshot::RegistrySnapshot(String^ name, RegistryHiveType^ hiveType) : Name(name), HiveType(hiveType)
{
    CaptureTime = DateTime::Now;
    Key = gcnew RegistryKey();
    Key->Name = hiveType->Name;
    Key->FullPath = hiveType->Name;
}

RegistrySnapshot^ RegShot::TakeSnapshot(RegistryHiveType^ hiveType)
{
    RegistrySnapshot^ hive = gcnew RegistrySnapshot("Snapshot " + NextCount(), hiveType);
    GenerateRegData(hive->HiveType->Hkey, nullptr, hive->Key);
    return hive;
}

List<RegistrySnapshot^>^ RegShot::TakeSnapshots(List<RegistryHiveType^>^ hiveTypes)
{
    List<RegistrySnapshot^>^ hives = gcnew List<RegistrySnapshot^>(hiveTypes->Count);
    for each (RegistryHiveType^ hiveType in hiveTypes)
	{
		hives->Add(TakeSnapshot(hiveType));
	}
    return hives;
}

List<RegistryKeyDiff^>^ RegShot::CompareSnapshots(RegistrySnapshot^ first, RegistrySnapshot^ second)
{
    if (first->HiveType != second->HiveType)
    {
        throw gcnew Exception("Comparing 2 snapshots of different registry hive");
    }

    List<RegistryKeyDiff^>^ diff = gcnew List<RegistryKeyDiff^>();
    CompareRegSnapshots(first->Key, second->Key, diff);
    return diff;
}

int MalwareToolbox::LibraryC::RegShot::RegShot::NextCount()
{
    return ++m_snapshot_count;
}

void RegShot::GenerateRegData(HKEY parent_key, LPWSTR key_name, RegistryKey^ reg_key)
{
    DWORD result;

    // Get key
    HKEY key = nullptr;

    result = RegOpenKeyEx(
        parent_key,
        key_name,
        0,
        KEY_READ,
        &key
    );
    if (result != ERROR_SUCCESS)
    {
        if (result != ERROR_ACCESS_DENIED) std::wcout << "Error opening key: " << result << " : " << key_name << std::endl;
        reg_key->SubKeys = gcnew Dictionary<String^, RegistryKey^>();
        reg_key->Values = gcnew Dictionary<String^, RegistryValue^>();
        return;
    }

    // Get key info
    DWORD sub_keys_count;
    DWORD max_sub_key_name_size;
    DWORD max_class_size;
    DWORD values_count;
    DWORD max_value_name_size;
    DWORD max_value_data_size;
    DWORD security_descriptor_size;

    RegQueryInfoKey(
        key,
        nullptr,
        nullptr,
        nullptr,
        &sub_keys_count,
        &max_sub_key_name_size,
        &max_class_size,
        &values_count,
        &max_value_name_size,
        &max_value_data_size,
        &security_descriptor_size,
        nullptr
    );
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error getting key info: " << result << std::endl;
        return;
    }

    // Increment size by one to include the null terminator
    max_sub_key_name_size++;
    max_value_name_size++;
    max_value_data_size++;

    RegistryKeyMeta^ meta_data = gcnew RegistryKeyMeta();

    meta_data->SubKeysCount = sub_keys_count;
    meta_data->MaxSubKeyNameSize = max_sub_key_name_size;
    meta_data->MaxClassSize = max_class_size;
    meta_data->ValuesCount = values_count;
    meta_data->MaxValueNameSize = max_value_name_size;
    meta_data->MaxValueDataSize = max_value_data_size;
    meta_data->SecurityDescriptorSize = security_descriptor_size;

    reg_key->Meta = meta_data;

    // Get values
    reg_key->Values = gcnew Dictionary<String^, RegistryValue^>(values_count);
    for (DWORD vindex = 0; vindex < values_count; vindex++)
    {
        const LPWSTR value_name = new WCHAR[max_value_name_size];
        DWORD value_name_size = max_value_name_size;
        DWORD type;
        const LPBYTE data = new BYTE[max_value_data_size];
        DWORD data_size = max_value_data_size;
        result = RegEnumValue(
            key,
            vindex,
            value_name,
            &value_name_size,
            nullptr,
            &type,
            data,
            &data_size
        );
        if (result != ERROR_SUCCESS)
        {
            std::wcout << "Error getting value: " << result << value_name_size << std::endl;
            break;
        }

        RegistryValue^ value = gcnew RegistryValue();

        value->Key = reg_key;
        value->Name = gcnew String(value_name);
        value->Type = type;
        value->ParseData(type, data, data_size);

        reg_key->Values->Add(value->Name, value);

        delete[] value_name;
        delete[] data;
    }

    // Get sub keys
    reg_key->SubKeys = gcnew Dictionary<String^, RegistryKey^>(sub_keys_count);
    for (DWORD sindex = 0; sindex < sub_keys_count; sindex++)
    {
        const LPWSTR sub_key_name = new WCHAR[max_sub_key_name_size];
        DWORD sub_key_name_size = max_sub_key_name_size;
        result = RegEnumKeyEx(
            key,
            sindex,
            sub_key_name,
            &sub_key_name_size,
            nullptr,
            nullptr,
            nullptr,
            nullptr
        );
        if (result != ERROR_SUCCESS)
        {
            std::cout << "Error getting sub key: " << result << std::endl;
            break;
        }

        RegistryKey^ sub_reg_key = gcnew RegistryKey();

        sub_reg_key->ParentKey = reg_key;
        sub_reg_key->Name = gcnew String(sub_key_name);
        sub_reg_key->FullPath = reg_key->FullPath + L"\\" + sub_reg_key->Name;

        GenerateRegData(key, sub_key_name, sub_reg_key);

        reg_key->SubKeys->TryAdd(sub_reg_key->Name, sub_reg_key);

        delete[] sub_key_name;
    }

    RegCloseKey(key);
}

void RegShot::CompareRegSnapshots(RegistryKey^ first, RegistryKey^ second, List<RegistryKeyDiff^>^ diff)
{
    // Compare keys
    if (first == nullptr)
    {
        if (second == nullptr)
        {
            throw gcnew Exception("Invalid registry key comparision, second key is null"); // This should never happen
        }
        diff->Add(gcnew RegistryKeyDiff(DiffType::Added, second));
        return;
    }
    else if (second == nullptr)
    {
        diff->Add(gcnew RegistryKeyDiff(DiffType::Deleted, first));
        return;
    }
    else if (first->Name != second->Name)
    {
        throw gcnew Exception("Invalid registry key comparision, name does not match"); // This should never happen
    }

    // Compare values
    List<RegistryValueDiff^>^ valuesDiff = gcnew List<RegistryValueDiff^>();

    HashSet<String^>^ value_names = gcnew HashSet<String^>(first->Values->Keys);
    value_names->UnionWith(second->Values->Keys);
    for each (String^ value_name in value_names)
    {
        RegistryValue^ first_reg_value = nullptr;
        RegistryValue^ second_reg_value = nullptr;
        first->Values->TryGetValue(value_name, first_reg_value);
        second->Values->TryGetValue(value_name, second_reg_value);

        if (first_reg_value == nullptr)
        {
            if (second_reg_value == nullptr)
            {
                throw gcnew Exception("Invalid registry value comparision, second value is null"); // This should never happen
            }
            valuesDiff->Add(gcnew RegistryValueDiff(DiffType::Added, nullptr, second_reg_value));
            continue;
        }
        else if (second_reg_value == nullptr)
        {
            valuesDiff->Add(gcnew RegistryValueDiff(DiffType::Deleted, first_reg_value));
            continue;
        }
        else if (first_reg_value->Name != second_reg_value->Name)
        {
            throw gcnew Exception("Invalid registry value comparision, name does not match"); // This should never happen
        }

        if (!first_reg_value->Equals(second_reg_value))
        {
            valuesDiff->Add(gcnew RegistryValueDiff(DiffType::Modified, first_reg_value, second_reg_value));
        }
    }

    if (valuesDiff->Count > 0)
    {
        diff->Add(gcnew RegistryKeyDiff(DiffType::Modified, second, valuesDiff));
    }

    // Compare sub keys
    HashSet<String^>^ sub_key_names = gcnew HashSet<String^>(first->SubKeys->Keys);
    sub_key_names->UnionWith(second->SubKeys->Keys);
    for each (String^ sub_key_name in sub_key_names)
    {
        RegistryKey^ first_sub_key = nullptr;
        RegistryKey^ second_sub_key = nullptr;
        first->SubKeys->TryGetValue(sub_key_name, first_sub_key);
        second->SubKeys->TryGetValue(sub_key_name, second_sub_key);

        CompareRegSnapshots(first_sub_key, second_sub_key, diff);
    }
}
