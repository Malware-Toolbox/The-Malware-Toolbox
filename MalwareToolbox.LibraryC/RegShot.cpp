#include "pch.h"
#include "Dynamic.h"
#include "Utils.h"

#include <iostream>
#include <phnt_windows.h>

using namespace System;
using namespace Collections::Generic;
using namespace MalwareToolbox::LibraryC::Dynamic;
using namespace MalwareToolbox::LibraryC::Utils;

void GenerateRegData(HKEY parent_key, LPWSTR key_name, RegistryKey^ reg_key)
{
    DWORD result;
    HKEY key = nullptr;

    result = RegOpenKeyEx(
        parent_key,
        key_name,
        0,
        KEY_READ,
        &key
    );
    if (result != ERROR_SUCCESS)
    {
        std::wcout << "Error opening key: " << result << " : " << key_name << std::endl;
        return;
    }

    DWORD sub_keys_count;
    DWORD max_sub_key_name_size;
    DWORD max_class_size;
    DWORD values_count;
    DWORD max_value_name_size;
    DWORD max_value_data_size;
    DWORD security_descriptor_size;

    RegQueryInfoKey(
        key,
        nullptr,
        nullptr,
        nullptr, 
        &sub_keys_count, 
        &max_sub_key_name_size,
        &max_class_size,
        &values_count, 
        &max_value_name_size, 
        &max_value_data_size, 
        &security_descriptor_size,
        nullptr
    );
    if (result != ERROR_SUCCESS)
    {
        std::cout << "Error getting key info: " << result << std::endl;
        return;
    }

    // Increment size by one to include the null terminator
    max_sub_key_name_size++;
    max_value_name_size++;
    max_value_data_size++;

    RegistryKeyMeta^ meta_data = gcnew RegistryKeyMeta();

    meta_data->SubKeysCount = sub_keys_count;
    meta_data->MaxSubKeyNameSize = max_sub_key_name_size;
    meta_data->MaxClassSize = max_class_size;
    meta_data->ValuesCount = values_count;
    meta_data->MaxValueNameSize = max_value_name_size;
    meta_data->MaxValueDataSize = max_value_data_size;
    meta_data->SecurityDescriptorSize = security_descriptor_size;

    reg_key->Meta = meta_data;

    reg_key->SubKeys = gcnew Dictionary<String^, RegistryKey^>(sub_keys_count);
    if (sub_keys_count > 0)
    {
        for (DWORD sindex = 0; sindex < sub_keys_count; sindex++)
        {
            const LPWSTR sub_key_name = new WCHAR[max_sub_key_name_size];
            DWORD sub_key_name_size = max_sub_key_name_size;
            result = RegEnumKeyEx(
                key,
                sindex,
                sub_key_name,
                &sub_key_name_size,
                nullptr,
                nullptr,
                nullptr,
                nullptr
            );
            if (result != ERROR_SUCCESS)
            {
                std::cout << "Error getting sub key: " << result << std::endl;
                break;
            }

            RegistryKey^ sub_reg_key = gcnew RegistryKey();

            sub_reg_key->ParentKey = reg_key;
            sub_reg_key->Name = gcnew String(sub_key_name);

            GenerateRegData(key, sub_key_name, sub_reg_key);

            reg_key->SubKeys->TryAdd(sub_reg_key->Name, sub_reg_key);

            delete[] sub_key_name;
        }
    }

    reg_key->Values = gcnew Dictionary<String^, RegistryValue<Object^>^>(values_count);
    if (values_count > 0)
    {
        for (DWORD vindex = 0; vindex < values_count; vindex++)
        {
            const LPWSTR value_name = new WCHAR[max_value_name_size];
            DWORD value_name_size = max_value_name_size;
            DWORD type;
            const LPBYTE data = new BYTE[max_value_data_size];
            DWORD data_size = max_value_data_size;

            result = RegEnumValue(
                key,
                vindex,
                value_name,
                &value_name_size,
                NULL,
                &type,
                data,
                &data_size
            );
            if (result != ERROR_SUCCESS)
            {
                std::wcout << "Error getting value: " << result << value_name_size << std::endl;
                break;
            }

            RegistryValue<Object^>^ value = gcnew RegistryValue<Object^>();

            value->Name = gcnew String(value_name);
            value->Type = type;

            switch (type)
            {
            case REG_SZ:
            case REG_EXPAND_SZ:
                value->Data = Converters::uchar_to_string_w(data, data_size / 2 - 1);
                break;
            case REG_DWORD:
                value->Data = Converters::uchar_to_int32(data);
                break;
            case REG_DWORD_BIG_ENDIAN:
                value->Data = Converters::uchar_to_int32_bigendian(data);
                break;
            case REG_QWORD:
                value->Data = Converters::uchar_to_int64(data);
                break;
            case REG_MULTI_SZ:
            {
	            String^ multi_str = Converters::uchar_to_string_w(data, data_size / 2 - 2);
	            value->Data = multi_str->Split('\0');
            }
                break;
            case REG_NONE:
                value->Data = nullptr;
                break;
            case REG_BINARY:
            default:
                // Fallback to byte array
                value->Data = Converters::uchar_to_bytearray(data, data_size);
            }

            reg_key->Values->Add(value->Name, value);

            delete[] value_name;
            delete[] data;
        }
    }

    RegCloseKey(key);
}

RegistryKey^ RegShot::TakeSnapshot()
{
    RegistryKey^ reg_current_user = gcnew RegistryKey();
    GenerateRegData(HKEY_CURRENT_USER, nullptr, reg_current_user);
    // RegistryKey^ reg_current_config = gcnew RegistryKey();
    // GenerateRegData(HKEY_CURRENT_CONFIG, nullptr, reg_current_config);
    // RegistryKey^ reg_local_machine = gcnew RegistryKey();
    // GenerateRegData(HKEY_LOCAL_MACHINE, nullptr, reg_local_machine);
    // RegistryKey^ reg_users = gcnew RegistryKey();
    // GenerateRegData(HKEY_USERS, nullptr, reg_users);

    return reg_current_user;
}

void RegShot::CompareSnapshots(RegistryKey^ first, RegistryKey^ second)
{
    if (first->Name != second->Name)
	{
		std::cout << "Key names don't match" << std::endl;
        return;
	}

    HashSet<String^>^ second_sub_key_names = gcnew HashSet<String^>(second->SubKeys->Keys);
    for each (RegistryKey^ first_sub_key in first->SubKeys->Values)
    {
        RegistryKey^ second_sub_key = nullptr;
        second->SubKeys->TryGetValue(first_sub_key->Name, second_sub_key);
	    if (second_sub_key)
	    {
            second_sub_key_names->Remove(first_sub_key->Name);
            CompareSnapshots(first_sub_key, second_sub_key);
	    }
        else
        {
            std::cout << "Sub key " << Converters::string_to_lpstr(first_sub_key->Name) << " has been removed" << std::endl;
        }
    }

    for each (String^ second_sub_key_name in second_sub_key_names)
    {
	    std::cout << "Sub key " << Converters::string_to_lpstr(second_sub_key_name) << " has been added" << std::endl;
    }

    HashSet<String^>^ second_value_names = gcnew HashSet<String^>(second->Values->Keys);
    for each (RegistryValue<Object^>^ first_reg_value in first->Values->Values)
    {
        RegistryValue<Object^>^ second_reg_value = nullptr;
        second->Values->TryGetValue(first_reg_value->Name, second_reg_value);
        if (second_reg_value)
        {
            second_value_names->Remove(first_reg_value->Name);
	        //TODO Value compare
        }
        else
        {
	        std::cout << "Value " << Converters::string_to_lpstr(first_reg_value->Name) << " has been removed" << std::endl;
        }
    }

    for each (String^ second_value_name in second_value_names)
    {
        std::cout << "Value " << Converters::string_to_lpstr(second_value_name) << " has been added" << std::endl;
    }
}
