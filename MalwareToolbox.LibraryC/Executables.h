#pragma once
#include "Utils.h"

using namespace System;
using namespace Collections::Generic;

namespace MalwareToolbox {
	namespace LibraryC {
		namespace Executables
		{
			public ref struct DosHeader
			{
				DWORD	Magic;					  // Magic number
				WORD	Cblp;                     // Bytes on last page of file
				WORD	Cp;                       // Pages in file
				WORD	Crlc;                     // Relocations
				WORD	Cparhdr;                  // Size of header in paragraphs
				WORD	MinAlloc;                 // Minimum extra paragraphs needed
				WORD	MaxAlloc;                 // Maximum extra paragraphs needed
				WORD	SS;                       // Initial (relative) SS value
				WORD	SP;                       // Initial SP value
				WORD	CheckSum;                 // Checksum
				WORD	IP;                       // Initial IP value
				WORD	CS;                       // Initial (relative) CS value
				WORD	Ifarlc;                   // File address of relocation table
				WORD	Ovno;                     // Overlay number
				//WORD	Res[4];                   // Reserved words
				WORD	OemId;                    // OEM identifier (for e_oeminfo)
				WORD	OemInfo;                  // OEM information; e_oemid specific
				//WORD	Res2[10];                 // Reserved words
				LONG	Lfanew;
			};

			public ref struct NtFileHeader
			{
				DWORD	Signature;

				WORD    Machine;
				WORD    NumberOfSections;
				DWORD   TimeDateStamp;
				DWORD   PointerToSymbolTable;
				DWORD   NumberOfSymbols;
				WORD    SizeOfOptionalHeader;
				WORD    Characteristics;
			};

			public ref struct NtOptionalHeader
			{
				// Standard fields
				WORD    Magic;
				BYTE    MajorLinkerVersion;
				BYTE    MinorLinkerVersion;
				DWORD   SizeOfCode;
				DWORD   SizeOfInitializedData;
				DWORD   SizeOfUninitializedData;
				DWORD   AddressOfEntryPoint;
				DWORD   BaseOfCode;

				// NT additional fields
				DWORD   SectionAlignment;
				DWORD   FileAlignment;
				WORD    MajorOperatingSystemVersion;
				WORD    MinorOperatingSystemVersion;
				WORD    MajorImageVersion;
				WORD    MinorImageVersion;
				WORD    MajorSubsystemVersion;
				WORD    MinorSubsystemVersion;
				DWORD   Win32VersionValue;
				DWORD   SizeOfImage;
				DWORD   SizeOfHeaders;
				DWORD   CheckSum;
				WORD    Subsystem;
				WORD    DllCharacteristics;
				DWORD   LoaderFlags;
				DWORD   NumberOfRvaAndSizes;
			};

			public ref struct NtOptionalHeader32 : public NtOptionalHeader
			{
				DWORD   BaseOfData;

				DWORD	ImageBase;
				DWORD	SizeOfStackReserve;
				DWORD	SizeOfStackCommit;
				DWORD	SizeOfHeapReserve;
				DWORD	SizeOfHeapCommit;
			};

			public ref struct NtOptionalHeader64 : public NtOptionalHeader
			{
				DWORD64	ImageBase;
				DWORD64	SizeOfStackReserve;
				DWORD64	SizeOfStackCommit;
				DWORD64 SizeOfHeapReserve;
				DWORD64 SizeOfHeapCommit;
			};

			public ref struct SectionHeader
			{
				String^ Name;
				DWORD   PhysicalAddress;
				DWORD   VirtualSize;
				DWORD   VirtualAddress;
				DWORD   SizeOfRawData;
				DWORD   PointerToRawData;
				DWORD   PointerToRelocations;
				DWORD   PointerToLinenumbers;
				WORD    NumberOfRelocations;
				WORD    NumberOfLinenumbers;
				DWORD   Characteristics;
			};

			public ref struct DataDirectory
			{
				DWORD   VirtualAddress;
				DWORD   Size;
			};

			public ref class PE : public Utils::File
			{
			public:
				static List<String^>^ KnownDlls(); //TODO Move this

				PE(String^ filePath);
				~PE();

				bool Load() override;
				void LoadHeaders();
				SectionHeader^ FindExecSection();
				bool IsDLL();
				bool Is64Bit();

				property DosHeader^ DosHeaders { DosHeader^ get(); }
				property NtFileHeader^ NtFileHeaders { NtFileHeader^ get(); }
				property NtOptionalHeader^ NtOptionalHeaders { NtOptionalHeader^ get(); }
				property array<SectionHeader^>^ SectionHeaders { array<SectionHeader^>^ get(); }
				
			private:
				DosHeader^ m_dos_headers;
				NtFileHeader^ m_nt_file_headers;
				NtOptionalHeader^ m_nt_optional_headers;
				array<SectionHeader^>^ m_section_headers;
			};
		}
	}
}
