#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <tchar.h>
#include <psapi.h>
#include <tlhelp32.h>
#include <processthreadsapi.h>
#define ARRAY_SIZE 1024
#include <winver.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <time.h>
#include <crtdbg.h>
#include <atlstr.h>
#include <winternl.h>
#include <windows.h>

namespace MalwareToolbox {
    namespace LibraryC {
        namespace ProcessAnalysis {

            typedef LONG    NTSTATUS;

            typedef NTSTATUS(WINAPI* pNtQIT)(HANDLE, LONG, PVOID, ULONG, PULONG);

            #define STATUS_SUCCESS    ((NTSTATUS)0x00000000L)

            #define ThreadQuerySetWin32StartAddress 9

            #pragma once

            public ref class Thread
            {
            public:
                DWORD ThreadID;
                DWORD ProcessID;
                SYSTEMTIME ThreadCreationTime;
                SYSTEMTIME ThreadExitTime;
                SYSTEMTIME ThreadKernelTime;
                SYSTEMTIME ThreadUserTime;
                DWORD64 StartAddress;
                INT ThreadPriority;
                // State and priorities 

                // returns the tid of threads in a given process pid. it is recursive and called from a while loop.
            // return 0 when there are no more threads.

                DWORD EnumerateThreads(DWORD pid)
                {// needs working for a simpler loop
                    char szText[MAX_PATH];

                    static BOOL bStarted;
                    static HANDLE hSnapPro, hSnapThread;
                    static LPPROCESSENTRY32 ppe32;
                    static PTHREADENTRY32 pte32;


                    if (!bStarted)
                    {
                        if (!bStarted)
                        {
                            bStarted++;
                            pte32 = new THREADENTRY32;
                            pte32->dwSize = sizeof(THREADENTRY32);

                            hSnapThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);

                            if (!hSnapThread)
                            {
                                std::cout << "GetLastError -> hSnapThread = CreateToolhelp32Snapshot " << GetLastError() << "\n";
                                delete pte32;
                                bStarted = 0;
                                return 0;
                            }

                            if (Thread32First(hSnapThread, pte32))
                            {
                                do
                                {
                                    if (pid == pte32->th32OwnerProcessID)
                                    {
                                        //printf("Thread32First pid: %d - tid: %d\n", pid, pte32->th32ThreadID);
                                        ThreadID = pte32->th32ThreadID;
                                        ProcessID = pid;
                                        return pte32->th32ThreadID;
                                    }
                                } while (Thread32Next(hSnapThread, pte32));
                            }
                            else
                                std::cout << "GetLastError ->Thread32First " << GetLastError() << "\n";
                        }
                    }

                    if (Thread32Next(hSnapThread, pte32))
                    {
                        do
                        {
                            if (pid == pte32->th32OwnerProcessID)
                            {
                                //printf("Thread32First pid: %d - tid: %d\n", pid, pte32->th32ThreadID);
                                ThreadID = pte32->th32ThreadID;
                                ProcessID = pid;
                                return pte32->th32ThreadID;
                            }
                        } while (Thread32Next(hSnapThread, pte32));
                    }
                    else
                        std::cout << "GetLastError ->Thread32First " << GetLastError() << "\n";

                    CloseHandle(hSnapThread);
                    bStarted = 0;
                    delete pte32;

                    //printf("finished EnumerateThreads\n");

                    return 0;
                }
                void Initalise()
                {
                    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, ThreadID);
                    if (hThread == 0) {

                    }
                    else
                    {
                        DWORD ThreadInformationSize = sizeof(THREAD_INFORMATION_CLASS);

                        // GetThreadInformation(hThread, );

                    //Thread time 
                        FILETIME tTimes[4];
                        GetThreadTimes(hThread, &tTimes[0], &tTimes[1], &tTimes[2], &tTimes[3]);
                        FileTimeToSystemTime(&tTimes[0], &ThreadCreationTime);
                        //std::cout << GetLastError();
                        FileTimeToSystemTime(&tTimes[1], &ThreadExitTime);
                        FileTimeToSystemTime(&tTimes[2], &ThreadKernelTime);
                        FileTimeToSystemTime(&tTimes[3], &ThreadUserTime);


                        // Get Thread Priority 
                        ThreadPriority = GetThreadPriority(hThread);
                        //PrintPriority();

                        //Get Thread State 

                        //StartAddress = GetThreadStartAddress(hThread);

                        //PrintAll();
                        // Read dwLow and dwHigh date time, kernel and user times are v small 
                        // Print the months and hours accordingly
                        //Read for NULL and filter accordingly 

                        //PrintTime();
                        //printf("Thread Creation time %d %d \n", tTimes[0].dwLowDateTime, tTimes[0].dwHighDateTime);
                        //printf("Thread Exit time %d %d \n", tTimes[1].dwLowDateTime, tTimes[1].dwHighDateTime);
                        //printf("Thread Kernel time %d %d \n", tTimes[2].dwLowDateTime, tTimes[2].dwHighDateTime);
                        //printf("Thread User time %d %d \n \n", tTimes[3].dwLowDateTime, tTimes[3].dwHighDateTime);
                        StartAddress = GetThreadStartAddress(hThread);
                        //printf("Start Address %x \n", StartAddress); 

                    }
                }
                void PrintAll() {
                    std::cout << "Process ID: " << ProcessID << "\n";
                    std::cout << "Thread ID: " << ThreadID << "\n";
                    PrintTime();
                    printf("Start Address %x \n", StartAddress); 
                    PrintPriority();
                    // Print Process Time 

                }
                void PrintTime()
                {
                    printf("Thread Creation time is %d year %d month %d day %d hour %d minute %d second %d millisecond \n", ThreadCreationTime.wYear, ThreadCreationTime.wMonth, ThreadCreationTime.wDayOfWeek, ThreadCreationTime.wDay, ThreadCreationTime.wHour, ThreadCreationTime.wMinute, ThreadCreationTime.wMilliseconds);
                    printf("Thread Exit time is %d year %d month %d day %d hour %d minute %d second %d millisecond\n", ThreadExitTime.wYear, ThreadExitTime.wMonth, ThreadExitTime.wDayOfWeek, ThreadExitTime.wDay, ThreadExitTime.wHour, ThreadExitTime.wMinute, ThreadExitTime.wMilliseconds);
                    printf("Thread Kernel time is %d year %d month %d day %d hour %d minute %d second %d millisecond\n", ThreadKernelTime.wYear, ThreadKernelTime.wMonth, ThreadKernelTime.wDayOfWeek, ThreadKernelTime.wDay, ThreadKernelTime.wHour, ThreadKernelTime.wMinute, ThreadKernelTime.wMilliseconds);
                    printf("Thread User time is %d year %d month %d day %d hour %d minute %d second %d millisecond\n\n", ThreadUserTime.wYear, ThreadUserTime.wMonth, ThreadUserTime.wDayOfWeek, ThreadUserTime.wDay, ThreadUserTime.wHour, ThreadUserTime.wMinute, ThreadUserTime.wMilliseconds);

                    // Default values if all null are 1601year 1month 1day 1 hour 0 minute 0 second 0 millisecond 
                }
                void PrintPriority()
                {
                    switch (ThreadPriority)
                    {
                    case 1:
                        printf("Priority above normal \n");
                        break;
                    case -1:
                        printf("Priority below normal \n");
                        break;
                    case 2:
                        printf("Priority highest \n");
                        break;
                    case 0:
                        printf("Priority normal \n");
                        break;
                    case -2:
                        printf("Prioirty lowest \n");
                        break;
                    case -15:
                        printf("Priority IDLE \n");
                        break;
                    case 15:
                        printf("Thread Priority Time Critical \n");
                        break;
                    default:
                        printf("REALTIME_PRIORITY CLASS %d", ThreadPriority);


                    }
                }

                void PrintStartAddress()
                {
                    //printf("Start Address %x \n", StartAddress);
                }
                DWORD64 WINAPI GetThreadStartAddress(HANDLE hThread)
                {
                    NTSTATUS ntStatus;
                    HANDLE hDupHandle;
                    DWORD64 dwStartAddress;

                    pNtQIT NtQueryInformationThread = (pNtQIT)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryInformationThread");

                    if (NtQueryInformationThread == NULL)
                        return 0;

                    HANDLE hCurrentProcess = GetCurrentProcess();
                    if (!DuplicateHandle(hCurrentProcess, hThread, hCurrentProcess, &hDupHandle, THREAD_QUERY_INFORMATION, FALSE, 0)) {
                        SetLastError(ERROR_ACCESS_DENIED);

                        return 1;
                    }

                    ntStatus = NtQueryInformationThread(hDupHandle, ThreadQuerySetWin32StartAddress, &dwStartAddress, sizeof(DWORD64), NULL);
                    CloseHandle(hDupHandle);
                    if (ntStatus != STATUS_SUCCESS) {
                        printf("NTSTATUS: %x", ntStatus);
                        return 2;
                    }
                    return dwStartAddress;

                }

            };
        }
    }
}