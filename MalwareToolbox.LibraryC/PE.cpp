#include "pch.h"
#include "Executables.h"
#include "Utils.h"

#include <cstdio>
#include <iostream>
#include <phnt_windows.h>
#include <phnt.h>

using namespace System;
using namespace Collections::Generic;
using namespace Runtime::InteropServices;
using namespace MalwareToolbox::LibraryC;
using namespace Executables;
using namespace Utils;

List<String^>^ PE::KnownDlls()
{
	//TODO Not done
	List<String^>^ ReturnList = gcnew List<String^>();

	HANDLE KnownDllDir = INVALID_HANDLE_VALUE;
	OBJECT_ATTRIBUTES oa;
	UNICODE_STRING name;
	NTSTATUS status;

	const PWCHAR KnownDllObjectName = L"\\KnownDlls";

	name.Length = (USHORT)wcslen(KnownDllObjectName) * sizeof(wchar_t);
	name.MaximumLength = (USHORT)wcslen(KnownDllObjectName) * sizeof(wchar_t);
	name.Buffer = KnownDllObjectName;

	InitializeObjectAttributes(
		&oa,
		&name,
		0,
		NULL,
		NULL
	);

	status = NtOpenDirectoryObject(
		&KnownDllDir,
		DIRECTORY_QUERY,
		&oa
	);

	if (!NT_SUCCESS(status)) {
		return ReturnList;
	}

	ReturnList->Add("test");
	return ReturnList;
}

PE::PE(String^ filePath): File(filePath)
{
}

PE::~PE()
{
	File::Unload();
	delete m_dos_headers;
	delete m_nt_headers;
}

bool PE::Load()
{
	if (!File::Load()) return false;
	LoadHeaders();
	return true;
}

void PE::LoadHeaders()
{
	const PIMAGE_DOS_HEADER dos_headers = static_cast<PIMAGE_DOS_HEADER>(m_file_data);
	m_dos_headers = gcnew DosHeader();
	m_dos_headers->Magic = dos_headers->e_magic;
	m_dos_headers->Lfanew = dos_headers->e_lfanew;

	const PIMAGE_NT_HEADERS32 nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS32>(reinterpret_cast<DWORD64>(m_file_data) + m_dos_headers->Lfanew);
	m_nt_headers = gcnew NtHeader32();
	m_nt_headers->Signature = nt_headers->Signature;

	m_nt_headers->Machine = nt_headers->FileHeader.Machine;
	m_nt_headers->NumberOfSections = nt_headers->FileHeader.NumberOfSections;
	m_nt_headers->SizeOfOptionalHeader = nt_headers->FileHeader.SizeOfOptionalHeader;

	m_nt_headers->Magic = nt_headers->OptionalHeader.Magic;
	m_nt_headers->SizeOfCode = nt_headers->OptionalHeader.SizeOfCode;
	m_nt_headers->SizeOfInitializedData = nt_headers->OptionalHeader.SizeOfInitializedData;
	m_nt_headers->SizeOfUninitializedData = nt_headers->OptionalHeader.SizeOfUninitializedData;
	m_nt_headers->AddressOfEntryPoint = nt_headers->OptionalHeader.AddressOfEntryPoint;
	m_nt_headers->BaseOfCode = nt_headers->OptionalHeader.BaseOfCode;

	m_nt_headers->ImageBase = nt_headers->OptionalHeader.ImageBase;
	m_nt_headers->SectionAlignment = nt_headers->OptionalHeader.SectionAlignment;
	m_nt_headers->FileAlignment = nt_headers->OptionalHeader.FileAlignment;
	m_nt_headers->SizeOfImage = nt_headers->OptionalHeader.SizeOfImage;
	m_nt_headers->SizeOfHeaders = nt_headers->OptionalHeader.SizeOfHeaders;

	m_section_headers = gcnew array<SectionHeader^>(m_nt_headers->NumberOfSections);
	DWORD64 section_offset = m_dos_headers->Lfanew + sizeof(IMAGE_NT_HEADERS32);
	for (int i = 0; i < m_nt_headers->NumberOfSections; i++) {
		const PIMAGE_SECTION_HEADER image_section_header = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<DWORD64>(m_file_data) + section_offset);

		SectionHeader^ section_header = gcnew SectionHeader();
		section_header->Name = Converters::uchar_to_string(image_section_header->Name, IMAGE_SIZEOF_SHORT_NAME);
		section_header->PhysicalAddress = image_section_header->Misc.PhysicalAddress;
		section_header->VirtualSize = image_section_header->Misc.VirtualSize;
		section_header->VirtualAddress = image_section_header->VirtualAddress;
		section_header->SizeOfRawData = image_section_header->SizeOfRawData;
		section_header->PointerToRawData = image_section_header->PointerToRawData;
		section_header->PointerToRelocations = image_section_header->PointerToRelocations;
		section_header->PointerToLinenumbers = image_section_header->PointerToLinenumbers;
		section_header->NumberOfRelocations = image_section_header->NumberOfRelocations;
		section_header->NumberOfLinenumbers = image_section_header->NumberOfLinenumbers;
		section_header->Characteristics = image_section_header->Characteristics;

		m_section_headers[i] = section_header;
		section_offset += IMAGE_SIZEOF_SECTION_HEADER;
	}
}

SectionHeader^ PE::FindExecSection()
{
	for each (SectionHeader^ section_header in m_section_headers)
	{
		if (m_nt_headers->AddressOfEntryPoint >= section_header->VirtualAddress && 
			m_nt_headers->AddressOfEntryPoint < section_header->VirtualAddress + section_header->VirtualSize)
		{
			if (m_nt_headers->AddressOfEntryPoint + section_header->SizeOfRawData > m_file_size)
			{
				std::cout << "Section out of bound" << std::endl;
			}

			return section_header;
		}
	}

	return nullptr;
}

DosHeader^ PE::DosHeaders::get()
{
	return m_dos_headers;
}

NtHeader32^ PE::NtHeaders::get()
{
	return m_nt_headers;
}

array<SectionHeader^>^ PE::SectionHeaders::get()
{
	return m_section_headers;
}
