#include "pch.h"
#include "Executables.h"
#include "Utils.h"

#include <cstdio>
#include <iostream>
#include <phnt_windows.h>
#include <phnt.h>

using namespace System;
using namespace Collections::Generic;
using namespace Runtime::InteropServices;
using namespace MalwareToolbox::LibraryC;
using namespace Executables;
using namespace Utils;

List<String^>^ PE::KnownDlls()
{
	//TODO Not done
	List<String^>^ ReturnList = gcnew List<String^>();

	HANDLE KnownDllDir = INVALID_HANDLE_VALUE;
	OBJECT_ATTRIBUTES oa;
	UNICODE_STRING name;
	NTSTATUS status;

	const PWCHAR KnownDllObjectName = L"\\KnownDlls";

	name.Length = (USHORT)wcslen(KnownDllObjectName) * sizeof(wchar_t);
	name.MaximumLength = (USHORT)wcslen(KnownDllObjectName) * sizeof(wchar_t);
	name.Buffer = KnownDllObjectName;

	InitializeObjectAttributes(
		&oa,
		&name,
		0,
		NULL,
		NULL
	);

	status = NtOpenDirectoryObject(
		&KnownDllDir,
		DIRECTORY_QUERY,
		&oa
	);

	if (!NT_SUCCESS(status)) {
		return ReturnList;
	}

	ReturnList->Add("test");
	return ReturnList;
}

PE::~PE()
{
	delete m_dos_headers;
	delete m_nt_file_headers;
	delete m_nt_optional_headers;
	delete m_section_headers;
}

bool PE::LoadHeaders()
{
	m_dos_headers = gcnew DosHeader();

	const PIMAGE_DOS_HEADER dos_headers = reinterpret_cast<PIMAGE_DOS_HEADER>(m_file->Data);
	if (dos_headers->e_magic != IMAGE_DOS_SIGNATURE) {
		return false;
	}
	m_dos_headers->Magic = dos_headers->e_magic;
	m_dos_headers->Lfanew = dos_headers->e_lfanew;
	//TODO fill up the rest of the dos headers

	m_nt_file_headers = gcnew NtFileHeader();

	const PDWORD nt_signature = reinterpret_cast<PDWORD>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew);
	const PIMAGE_FILE_HEADER nt_file_headers = reinterpret_cast<PIMAGE_FILE_HEADER>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew + sizeof(DWORD));
	m_nt_file_headers->Signature = *nt_signature;
	m_nt_file_headers->Machine = nt_file_headers->Machine;
	m_nt_file_headers->NumberOfSections = nt_file_headers->NumberOfSections;
	m_nt_file_headers->TimeDateStamp = nt_file_headers->TimeDateStamp;
	m_nt_file_headers->PointerToSymbolTable = nt_file_headers->PointerToSymbolTable;
	m_nt_file_headers->NumberOfSymbols = nt_file_headers->NumberOfSymbols;
	m_nt_file_headers->SizeOfOptionalHeader = nt_file_headers->SizeOfOptionalHeader;
	m_nt_file_headers->Characteristics = nt_file_headers->Characteristics;

	DWORD nt_header_offset;
	IMAGE_DATA_DIRECTORY import_data_dir;

	if (Is64Bit()) {
		nt_header_offset = sizeof(IMAGE_NT_HEADERS64);
		NtOptionalHeader64^ nt_optional_headers = gcnew NtOptionalHeader64();

		const PIMAGE_OPTIONAL_HEADER64 nt_headers = reinterpret_cast<PIMAGE_OPTIONAL_HEADER64>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));
		nt_optional_headers->Magic = nt_headers->Magic;
		nt_optional_headers->MajorLinkerVersion = nt_headers->MajorLinkerVersion;
		nt_optional_headers->MinorLinkerVersion = nt_headers->MinorLinkerVersion;
		nt_optional_headers->SizeOfCode = nt_headers->SizeOfCode;
		nt_optional_headers->SizeOfInitializedData = nt_headers->SizeOfInitializedData;
		nt_optional_headers->SizeOfUninitializedData = nt_headers->SizeOfUninitializedData;
		nt_optional_headers->AddressOfEntryPoint = nt_headers->AddressOfEntryPoint;
		nt_optional_headers->BaseOfCode = nt_headers->BaseOfCode;

		nt_optional_headers->SectionAlignment = nt_headers->SectionAlignment;
		nt_optional_headers->FileAlignment = nt_headers->FileAlignment;
		nt_optional_headers->MajorOperatingSystemVersion = nt_headers->MajorOperatingSystemVersion;
		nt_optional_headers->MinorOperatingSystemVersion = nt_headers->MinorOperatingSystemVersion;
		nt_optional_headers->MajorImageVersion = nt_headers->MajorImageVersion;
		nt_optional_headers->MinorImageVersion = nt_headers->MinorImageVersion;
		nt_optional_headers->MajorSubsystemVersion = nt_headers->MajorSubsystemVersion;
		nt_optional_headers->MinorSubsystemVersion = nt_headers->MinorSubsystemVersion;
		nt_optional_headers->Win32VersionValue = nt_headers->Win32VersionValue;
		nt_optional_headers->SizeOfImage = nt_headers->SizeOfImage;
		nt_optional_headers->SizeOfHeaders = nt_headers->SizeOfHeaders;
		nt_optional_headers->CheckSum = nt_headers->CheckSum;
		nt_optional_headers->Subsystem = nt_headers->Subsystem;
		nt_optional_headers->DllCharacteristics = nt_headers->DllCharacteristics;
		nt_optional_headers->LoaderFlags = nt_headers->LoaderFlags;
		nt_optional_headers->NumberOfRvaAndSizes = nt_headers->NumberOfRvaAndSizes;

		nt_optional_headers->ImageBase = nt_headers->ImageBase;
		nt_optional_headers->SizeOfStackReserve = nt_headers->SizeOfStackReserve;
		nt_optional_headers->SizeOfStackCommit = nt_headers->SizeOfStackCommit;
		nt_optional_headers->SizeOfHeapReserve = nt_headers->SizeOfHeapReserve;
		nt_optional_headers->SizeOfHeapCommit = nt_headers->SizeOfHeapCommit;

		import_data_dir = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

		m_nt_optional_headers = nt_optional_headers;
	}
	else
	{
		nt_header_offset = sizeof(IMAGE_NT_HEADERS32);
		NtOptionalHeader32^ nt_optional_headers = gcnew NtOptionalHeader32();

		const PIMAGE_OPTIONAL_HEADER32 nt_headers = reinterpret_cast<PIMAGE_OPTIONAL_HEADER32>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));
		nt_optional_headers->Magic = nt_headers->Magic;
		nt_optional_headers->MajorLinkerVersion = nt_headers->MajorLinkerVersion;
		nt_optional_headers->MinorLinkerVersion = nt_headers->MinorLinkerVersion;
		nt_optional_headers->SizeOfCode = nt_headers->SizeOfCode;
		nt_optional_headers->SizeOfInitializedData = nt_headers->SizeOfInitializedData;
		nt_optional_headers->SizeOfUninitializedData = nt_headers->SizeOfUninitializedData;
		nt_optional_headers->AddressOfEntryPoint = nt_headers->AddressOfEntryPoint;
		nt_optional_headers->BaseOfCode = nt_headers->BaseOfCode;
		nt_optional_headers->BaseOfData = nt_headers->BaseOfData;

		nt_optional_headers->SectionAlignment = nt_headers->SectionAlignment;
		nt_optional_headers->FileAlignment = nt_headers->FileAlignment;
		nt_optional_headers->MajorOperatingSystemVersion = nt_headers->MajorOperatingSystemVersion;
		nt_optional_headers->MinorOperatingSystemVersion = nt_headers->MinorOperatingSystemVersion;
		nt_optional_headers->MajorImageVersion = nt_headers->MajorImageVersion;
		nt_optional_headers->MinorImageVersion = nt_headers->MinorImageVersion;
		nt_optional_headers->MajorSubsystemVersion = nt_headers->MajorSubsystemVersion;
		nt_optional_headers->MinorSubsystemVersion = nt_headers->MinorSubsystemVersion;
		nt_optional_headers->Win32VersionValue = nt_headers->Win32VersionValue;
		nt_optional_headers->SizeOfImage = nt_headers->SizeOfImage;
		nt_optional_headers->SizeOfHeaders = nt_headers->SizeOfHeaders;
		nt_optional_headers->CheckSum = nt_headers->CheckSum;
		nt_optional_headers->Subsystem = nt_headers->Subsystem;
		nt_optional_headers->DllCharacteristics = nt_headers->DllCharacteristics;
		nt_optional_headers->LoaderFlags = nt_headers->LoaderFlags;
		nt_optional_headers->NumberOfRvaAndSizes = nt_headers->NumberOfRvaAndSizes;

		nt_optional_headers->ImageBase = nt_headers->ImageBase;
		nt_optional_headers->SizeOfStackReserve = nt_headers->SizeOfStackReserve;
		nt_optional_headers->SizeOfStackCommit = nt_headers->SizeOfStackCommit;
		nt_optional_headers->SizeOfHeapReserve = nt_headers->SizeOfHeapReserve;
		nt_optional_headers->SizeOfHeapCommit = nt_headers->SizeOfHeapCommit;

		import_data_dir = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

		m_nt_optional_headers = nt_optional_headers;
	}

	SectionHeader^ import_section = nullptr;
	m_section_headers = gcnew array<SectionHeader^>(m_nt_file_headers->NumberOfSections);
	
	DWORD64 section_offset = m_dos_headers->Lfanew + nt_header_offset;
	for (int i = 0; i < m_nt_file_headers->NumberOfSections; i++) {
		const PIMAGE_SECTION_HEADER image_section_header = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<DWORD64>(m_file->Data) + section_offset);

		SectionHeader^ section_header = gcnew SectionHeader();
		section_header->Name = Converters::uchar_to_string(image_section_header->Name, IMAGE_SIZEOF_SHORT_NAME);
		section_header->PhysicalAddress = image_section_header->Misc.PhysicalAddress;
		section_header->VirtualSize = image_section_header->Misc.VirtualSize;
		section_header->VirtualAddress = image_section_header->VirtualAddress;
		section_header->SizeOfRawData = image_section_header->SizeOfRawData;
		section_header->PointerToRawData = image_section_header->PointerToRawData;
		section_header->PointerToRelocations = image_section_header->PointerToRelocations;
		section_header->PointerToLinenumbers = image_section_header->PointerToLinenumbers;
		section_header->NumberOfRelocations = image_section_header->NumberOfRelocations;
		section_header->NumberOfLinenumbers = image_section_header->NumberOfLinenumbers;
		section_header->Characteristics = image_section_header->Characteristics;

		if (import_data_dir.VirtualAddress >= section_header->VirtualAddress && import_data_dir.VirtualAddress < section_header->VirtualAddress + section_header->VirtualSize)
		{
			import_section = section_header;
		}

		m_section_headers[i] = section_header;
		section_offset += IMAGE_SIZEOF_SECTION_HEADER;
	}
	DWORD64 import_offset = m_file->DataPointer + import_section->PointerToRawData;
	PIMAGE_IMPORT_DESCRIPTOR import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)(import_offset + (import_data_dir.VirtualAddress - import_section->VirtualAddress));

	printf("%s", import_offset + (import_descriptor->Name - import_section->VirtualAddress));

	//std::cout << import_descriptor->Name << std::endl;

	return true;
}

SectionHeader^ PE::FindExecSection()
{
	for each (SectionHeader^ section_header in m_section_headers)
	{
		if (m_nt_optional_headers->AddressOfEntryPoint >= section_header->VirtualAddress && 
			m_nt_optional_headers->AddressOfEntryPoint < section_header->VirtualAddress + section_header->VirtualSize)
		{
			// if (m_nt_optional_headers->AddressOfEntryPoint + section_header->SizeOfRawData > m_file_size)
			// {
			// 	std::cout << "Section out of bound" << std::endl;
			// }

			return section_header;
		}
	}

	return nullptr;
}

bool PE::IsDLL()
{
	return m_nt_file_headers->Characteristics & IMAGE_FILE_DLL;
}

bool PE::Is64Bit()
{
	return m_nt_file_headers->Machine == IMAGE_FILE_MACHINE_AMD64;
}

Utils::File^ PE::File::get()
{
	return m_file;
}

DosHeader^ PE::DosHeaders::get()
{
	return m_dos_headers;
}

NtFileHeader^ PE::NtFileHeaders::get()
{
	return m_nt_file_headers;
}

NtOptionalHeader^ PE::NtOptionalHeaders::get()
{
	return m_nt_optional_headers;
}

array<SectionHeader^>^ PE::SectionHeaders::get()
{
	return m_section_headers;
}
