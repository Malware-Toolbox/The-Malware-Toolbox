#include "pch.h"
#include "Executables.h"
#include "Utils.h"

#include <cstdio>
#include <iostream>
#include <phnt_windows.h>
#include <phnt.h>

using namespace System;
using namespace Collections::Generic;
using namespace Runtime::InteropServices;
using namespace MalwareToolbox::LibraryC;
using namespace Executables;
using namespace Utils;

List<String^>^ PE::KnownDlls()
{
	//TODO Not done
	List<String^>^ ReturnList = gcnew List<String^>();

	HANDLE KnownDllDir = INVALID_HANDLE_VALUE;
	OBJECT_ATTRIBUTES oa;
	UNICODE_STRING name;
	NTSTATUS status;

	const PWCHAR KnownDllObjectName = L"\\KnownDlls";

	name.Length = (USHORT)wcslen(KnownDllObjectName) * sizeof(wchar_t);
	name.MaximumLength = (USHORT)wcslen(KnownDllObjectName) * sizeof(wchar_t);
	name.Buffer = KnownDllObjectName;

	InitializeObjectAttributes(
		&oa,
		&name,
		0,
		NULL,
		NULL
	);

	status = NtOpenDirectoryObject(
		&KnownDllDir,
		DIRECTORY_QUERY,
		&oa
	);

	if (!NT_SUCCESS(status)) {
		return ReturnList;
	}

	ReturnList->Add("test");
	return ReturnList;
}

PE::~PE()
{
	delete m_dos_headers;
	delete m_nt_file_headers;
	delete m_nt_optional_headers;
	delete m_section_headers;
}

bool PE::LoadHeaders()
{
	m_file->Lock = true;

	m_dos_headers = gcnew DosHeader();

	const PIMAGE_DOS_HEADER dos_headers = reinterpret_cast<PIMAGE_DOS_HEADER>(m_file->Data);
	if (dos_headers->e_magic != IMAGE_DOS_SIGNATURE) {
		m_file->Lock = false;
		return false;
	}

	m_dos_headers->Magic = dos_headers->e_magic;
	m_dos_headers->Lfanew = dos_headers->e_lfanew;
	//TODO fill up the rest of the dos headers

	m_nt_file_headers = gcnew NtFileHeader();

	const PDWORD nt_signature = reinterpret_cast<PDWORD>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew);
	const PIMAGE_FILE_HEADER nt_file_headers = reinterpret_cast<PIMAGE_FILE_HEADER>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew + sizeof(DWORD));
	m_nt_file_headers->Signature = *nt_signature;
	m_nt_file_headers->Machine = nt_file_headers->Machine;
	m_nt_file_headers->NumberOfSections = nt_file_headers->NumberOfSections;
	m_nt_file_headers->TimeDateStamp = nt_file_headers->TimeDateStamp;
	m_nt_file_headers->PointerToSymbolTable = nt_file_headers->PointerToSymbolTable;
	m_nt_file_headers->NumberOfSymbols = nt_file_headers->NumberOfSymbols;
	m_nt_file_headers->SizeOfOptionalHeader = nt_file_headers->SizeOfOptionalHeader;
	m_nt_file_headers->Characteristics = nt_file_headers->Characteristics;

	DWORD64 filetype_offset = m_file->DataPointer + m_dos_headers->Lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER);
	filetype = (reinterpret_cast<PWORD>(filetype_offset));

	// Rich Header 
	m_rich_header = gcnew RichHeader();
	DWORD64 buffer_offset = m_file->DataPointer + m_dos_headers->Lfanew;
	unsigned char* buffer = reinterpret_cast<unsigned char*>(reinterpret_cast<DWORD64>(m_file->Data));

	int richoffset = 0;
	for (int i =0; i<= m_dos_headers->Lfanew;i++)
	{
		if (buffer[i] == 0x52 && buffer[i + 1] == 0x69)
		{
			richoffset = i;
			break;
		}
	}
	unsigned char Decryptionkey[4];
	memcpy(Decryptionkey, &buffer[richoffset + 4], 4);
	int richsize = 0;
	int dansoffset = richoffset - 4;
	while (true)
	{
		unsigned char tmp[4];
		memcpy(tmp, &buffer[dansoffset], 4);
		for (int i = 0; i < 4; i++)
		{
			tmp[i] = tmp[i] ^ Decryptionkey[i];
		}
		richsize += 4;
		if (tmp[0] == 0x44 && tmp[1] == 0x61) {
			break;
		}
		dansoffset -= 4;
	}
	char* richbuffer = new char[richsize];
	memcpy(richbuffer, &buffer[dansoffset], richsize);
	for (int i = 0; i < richsize; i += 4)
	{
		richbuffer[0] = richbuffer[0] ^ Decryptionkey[0];
		richbuffer[1] = richbuffer[1] ^ Decryptionkey[1];
		richbuffer[2] = richbuffer[2] ^ Decryptionkey[2];
		richbuffer[3] = richbuffer[3] ^ Decryptionkey[3];
	}
	m_rich_header->size = richsize;
	m_rich_header->DansOffset = dansoffset;
	m_rich_header->entryno = (richsize - 16) / 8;
	m_rich_header ->DecryptionKey= *Decryptionkey;
	m_rich_header->entries = gcnew List<Richentry^>();
	for (int i = 0; i < m_rich_header->entryno; i++)
	{
		unsigned char versionbuffer[2];
		unsigned char idbuffer[2];
		unsigned char countbuffer[4];
		memcpy(versionbuffer, &richbuffer[16 + i * 8], 2);
		memcpy(idbuffer, &richbuffer[16 + (i * 8) + 2], 2);
		memcpy(countbuffer, &richbuffer[16 + (i * 8) + 4], 4);
		Richentry^ entry = gcnew Richentry();
		entry->BUILDID = *versionbuffer;
		entry->PROID = *idbuffer;
		entry->count = *countbuffer;
		m_rich_header->entries->Add(entry);
	}
	// Rich header end

	DWORD nt_header_offset;
	PIMAGE_DATA_DIRECTORY data_dirs;
	IMAGE_DATA_DIRECTORY import_data_dir;
	IMAGE_DATA_DIRECTORY EXPORT_DIRECTORY;
	IMAGE_DATA_DIRECTORY IMPORT_DIRECTORY;
	IMAGE_DATA_DIRECTORY RESOURCE_DIRECTORY;
	IMAGE_DATA_DIRECTORY EXCEPTION_DIRECTORY;
	IMAGE_DATA_DIRECTORY SECURITY_DIRECTORY;
	IMAGE_DATA_DIRECTORY BASERELOC_DIRECTORY;
	IMAGE_DATA_DIRECTORY DEBUG_DIRECTORY;
	IMAGE_DATA_DIRECTORY ARCHITECTURE_DIRECTORY;
	IMAGE_DATA_DIRECTORY GLOBALPTR_DIRECTORY;
	IMAGE_DATA_DIRECTORY TLS_DIRECTORY;
	IMAGE_DATA_DIRECTORY LOAD_CONFIG_DIRECTORY;
	IMAGE_DATA_DIRECTORY BOUND_IMPORT_DIRECTORY;
	IMAGE_DATA_DIRECTORY IAT_DIRECTORY;
	IMAGE_DATA_DIRECTORY DELAY_IMPORT_DIRECTORY;
	IMAGE_DATA_DIRECTORY COM_DESCRIPTOR_DIRECTORY;

	if (Is64Bit()) {
		nt_header_offset = sizeof(IMAGE_NT_HEADERS64);
		NtOptionalHeader64^ nt_optional_headers = gcnew NtOptionalHeader64();

		const PIMAGE_OPTIONAL_HEADER64 nt_headers = reinterpret_cast<PIMAGE_OPTIONAL_HEADER64>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));
		nt_optional_headers->Magic = nt_headers->Magic;
		nt_optional_headers->MajorLinkerVersion = nt_headers->MajorLinkerVersion;
		nt_optional_headers->MinorLinkerVersion = nt_headers->MinorLinkerVersion;
		nt_optional_headers->SizeOfCode = nt_headers->SizeOfCode;
		nt_optional_headers->SizeOfInitializedData = nt_headers->SizeOfInitializedData;
		nt_optional_headers->SizeOfUninitializedData = nt_headers->SizeOfUninitializedData;
		nt_optional_headers->AddressOfEntryPoint = nt_headers->AddressOfEntryPoint;
		nt_optional_headers->BaseOfCode = nt_headers->BaseOfCode;

		nt_optional_headers->SectionAlignment = nt_headers->SectionAlignment;
		nt_optional_headers->FileAlignment = nt_headers->FileAlignment;
		nt_optional_headers->MajorOperatingSystemVersion = nt_headers->MajorOperatingSystemVersion;
		nt_optional_headers->MinorOperatingSystemVersion = nt_headers->MinorOperatingSystemVersion;
		nt_optional_headers->MajorImageVersion = nt_headers->MajorImageVersion;
		nt_optional_headers->MinorImageVersion = nt_headers->MinorImageVersion;
		nt_optional_headers->MajorSubsystemVersion = nt_headers->MajorSubsystemVersion;
		nt_optional_headers->MinorSubsystemVersion = nt_headers->MinorSubsystemVersion;
		nt_optional_headers->Win32VersionValue = nt_headers->Win32VersionValue;
		nt_optional_headers->SizeOfImage = nt_headers->SizeOfImage;
		nt_optional_headers->SizeOfHeaders = nt_headers->SizeOfHeaders;
		nt_optional_headers->CheckSum = nt_headers->CheckSum;
		nt_optional_headers->Subsystem = nt_headers->Subsystem;
		nt_optional_headers->DllCharacteristics = nt_headers->DllCharacteristics;
		nt_optional_headers->LoaderFlags = nt_headers->LoaderFlags;
		nt_optional_headers->NumberOfRvaAndSizes = nt_headers->NumberOfRvaAndSizes;

		nt_optional_headers->ImageBase = nt_headers->ImageBase;
		nt_optional_headers->SizeOfStackReserve = nt_headers->SizeOfStackReserve;
		nt_optional_headers->SizeOfStackCommit = nt_headers->SizeOfStackCommit;
		nt_optional_headers->SizeOfHeapReserve = nt_headers->SizeOfHeapReserve;
		nt_optional_headers->SizeOfHeapCommit = nt_headers->SizeOfHeapCommit;


		data_dirs = nt_headers->DataDirectory;
		// Added for the sake of continuity in report but probably not needed.. 
		import_data_dir = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
		EXPORT_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
		IMPORT_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
		RESOURCE_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];
		EXCEPTION_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
		SECURITY_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY];
		BASERELOC_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		DEBUG_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
		ARCHITECTURE_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_ARCHITECTURE];
		GLOBALPTR_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_GLOBALPTR];
		TLS_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
		LOAD_CONFIG_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG];
		BOUND_IMPORT_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT];
		IAT_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT];
		DELAY_IMPORT_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];
		COM_DESCRIPTOR_DIRECTORY = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];
		// 

		m_nt_optional_headers = nt_optional_headers;
	}
	else
	{
		nt_header_offset = sizeof(IMAGE_NT_HEADERS32);
		NtOptionalHeader32^ nt_optional_headers = gcnew NtOptionalHeader32();

		const PIMAGE_OPTIONAL_HEADER32 nt_headers = reinterpret_cast<PIMAGE_OPTIONAL_HEADER32>(reinterpret_cast<DWORD64>(m_file->Data) + m_dos_headers->Lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER));
		nt_optional_headers->Magic = nt_headers->Magic;
		nt_optional_headers->MajorLinkerVersion = nt_headers->MajorLinkerVersion;
		nt_optional_headers->MinorLinkerVersion = nt_headers->MinorLinkerVersion;
		nt_optional_headers->SizeOfCode = nt_headers->SizeOfCode;
		nt_optional_headers->SizeOfInitializedData = nt_headers->SizeOfInitializedData;
		nt_optional_headers->SizeOfUninitializedData = nt_headers->SizeOfUninitializedData;
		nt_optional_headers->AddressOfEntryPoint = nt_headers->AddressOfEntryPoint;
		nt_optional_headers->BaseOfCode = nt_headers->BaseOfCode;
		nt_optional_headers->BaseOfData = nt_headers->BaseOfData;

		nt_optional_headers->SectionAlignment = nt_headers->SectionAlignment;
		nt_optional_headers->FileAlignment = nt_headers->FileAlignment;
		nt_optional_headers->MajorOperatingSystemVersion = nt_headers->MajorOperatingSystemVersion;
		nt_optional_headers->MinorOperatingSystemVersion = nt_headers->MinorOperatingSystemVersion;
		nt_optional_headers->MajorImageVersion = nt_headers->MajorImageVersion;
		nt_optional_headers->MinorImageVersion = nt_headers->MinorImageVersion;
		nt_optional_headers->MajorSubsystemVersion = nt_headers->MajorSubsystemVersion;
		nt_optional_headers->MinorSubsystemVersion = nt_headers->MinorSubsystemVersion;
		nt_optional_headers->Win32VersionValue = nt_headers->Win32VersionValue;
		nt_optional_headers->SizeOfImage = nt_headers->SizeOfImage;
		nt_optional_headers->SizeOfHeaders = nt_headers->SizeOfHeaders;
		nt_optional_headers->CheckSum = nt_headers->CheckSum;
		nt_optional_headers->Subsystem = nt_headers->Subsystem;
		nt_optional_headers->DllCharacteristics = nt_headers->DllCharacteristics;
		nt_optional_headers->LoaderFlags = nt_headers->LoaderFlags;
		nt_optional_headers->NumberOfRvaAndSizes = nt_headers->NumberOfRvaAndSizes;

		nt_optional_headers->ImageBase = nt_headers->ImageBase;
		nt_optional_headers->SizeOfStackReserve = nt_headers->SizeOfStackReserve;
		nt_optional_headers->SizeOfStackCommit = nt_headers->SizeOfStackCommit;
		nt_optional_headers->SizeOfHeapReserve = nt_headers->SizeOfHeapReserve;
		nt_optional_headers->SizeOfHeapCommit = nt_headers->SizeOfHeapCommit;

		data_dirs = nt_headers->DataDirectory;
		import_data_dir = nt_headers->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

		m_nt_optional_headers = nt_optional_headers;
	}

	m_data_directories = gcnew array<DataDirectory^>(IMAGE_NUMBEROF_DIRECTORY_ENTRIES);
	for (int i=0; i<IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)
	{
		DataDirectory^ data_dir = gcnew DataDirectory();
		data_dir->Size = data_dirs[i].Size;
		data_dir->VirtualAddress = data_dirs[i].VirtualAddress;
		m_data_directories[i] = data_dir;
	}

	SectionHeader^ import_section = nullptr;
	m_section_headers = gcnew array<SectionHeader^>(m_nt_file_headers->NumberOfSections);
	
	DWORD64 section_offset = m_dos_headers->Lfanew + nt_header_offset;
	for (int i = 0; i < m_nt_file_headers->NumberOfSections; i++) {
		const PIMAGE_SECTION_HEADER image_section_header = reinterpret_cast<PIMAGE_SECTION_HEADER>(reinterpret_cast<DWORD64>(m_file->Data) + section_offset);

		SectionHeader^ section_header = gcnew SectionHeader();
		section_header->Name = Converters::uchar_to_string(image_section_header->Name, IMAGE_SIZEOF_SHORT_NAME);
		section_header->PhysicalAddress = image_section_header->Misc.PhysicalAddress;
		section_header->VirtualSize = image_section_header->Misc.VirtualSize;
		section_header->VirtualAddress = image_section_header->VirtualAddress;
		section_header->SizeOfRawData = image_section_header->SizeOfRawData;
		section_header->PointerToRawData = image_section_header->PointerToRawData;
		section_header->PointerToRelocations = image_section_header->PointerToRelocations;
		section_header->PointerToLinenumbers = image_section_header->PointerToLinenumbers;
		section_header->NumberOfRelocations = image_section_header->NumberOfRelocations;
		section_header->NumberOfLinenumbers = image_section_header->NumberOfLinenumbers;
		section_header->Characteristics = image_section_header->Characteristics;

		if (import_data_dir.VirtualAddress >= section_header->VirtualAddress && import_data_dir.VirtualAddress < section_header->VirtualAddress + section_header->VirtualSize)
		{
			import_section = section_header;
		}

		m_section_headers[i] = section_header;
		section_offset += IMAGE_SIZEOF_SECTION_HEADER;
	}

	m_dll_imports = gcnew List<DllImport^>();

	DWORD64 import_offset = m_file->DataPointer + import_section->PointerToRawData;
	PIMAGE_IMPORT_DESCRIPTOR import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(import_offset + (import_data_dir.VirtualAddress - import_section->VirtualAddress));

	while (import_descriptor->Name != 0)
	{
		DllImport^ dll_import = gcnew DllImport();
		dll_import->Characteristics = import_descriptor->Characteristics;
		dll_import->OriginalFirstThunk = import_descriptor->OriginalFirstThunk;
		dll_import->TimeDateStamp = import_descriptor->TimeDateStamp;
		dll_import->ForwarderChain = import_descriptor->ForwarderChain;
		dll_import->Name = Converters::uchar_to_string(reinterpret_cast<unsigned char*>(import_offset) + (import_descriptor->Name - import_section->VirtualAddress));
		dll_import->FirstThunk = import_descriptor->FirstThunk;

		dll_import->Functions = gcnew List<DllFunc^>();
		const DWORD thunk = import_descriptor->OriginalFirstThunk == 0 ? import_descriptor->FirstThunk : import_descriptor->OriginalFirstThunk;

		if (Is64Bit())
		{
			PIMAGE_THUNK_DATA64 thunk_data = reinterpret_cast<PIMAGE_THUNK_DATA64>(import_offset + thunk - import_section->VirtualAddress);
			ULONGLONG address_of_data = thunk_data->u1.AddressOfData;
			while (thunk_data->u1.AddressOfData != 0)
			{
				DllFunc^ dll_func = gcnew DllFunc();
				PIMAGE_IMPORT_BY_NAME import_by_name = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(import_offset + (thunk_data->u1.AddressOfData - import_section->VirtualAddress));
				dll_func->Hint = import_by_name->Hint;
				dll_func->Name = Converters::uchar_to_string(reinterpret_cast<unsigned char*>(import_by_name->Name));

				dll_import->Functions->Add(dll_func);
				thunk_data++;
			}
		}
		else
		{
			PIMAGE_THUNK_DATA32 thunk_data = reinterpret_cast<PIMAGE_THUNK_DATA32>(import_offset + thunk - import_section->VirtualAddress);
			while (thunk_data->u1.AddressOfData != 0)
			{
				DllFunc^ dll_func = gcnew DllFunc();
				PIMAGE_IMPORT_BY_NAME import_by_name = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(import_offset + (thunk_data->u1.AddressOfData - import_section->VirtualAddress));
				dll_func->Hint = import_by_name->Hint;
				dll_func->Name = Converters::uchar_to_string(reinterpret_cast<unsigned char*>(import_by_name->Name));

				dll_import->Functions->Add(dll_func);
				thunk_data++;
			}
		}

		m_dll_imports->Add(dll_import);
		import_descriptor++;
	}

	m_file->Lock = false;

	return true;
}

SectionHeader^ PE::FindExecSection()
{
	for each (SectionHeader^ section_header in m_section_headers)
	{
		if (m_nt_optional_headers->AddressOfEntryPoint >= section_header->VirtualAddress && 
			m_nt_optional_headers->AddressOfEntryPoint < section_header->VirtualAddress + section_header->VirtualSize)
		{
			// if (m_nt_optional_headers->AddressOfEntryPoint + section_header->SizeOfRawData > m_file_size)
			// {
			// 	std::cout << "Section out of bound" << std::endl;
			// }

			return section_header;
		}
	}

	return nullptr;
}

bool PE::IsDLL()
{
	return m_nt_file_headers->Characteristics & IMAGE_FILE_DLL;
}

bool PE::Is64Bit()
{
	return *filetype == IMAGE_NT_OPTIONAL_HDR64_MAGIC;
}

Utils::WinFile^ PE::File::get()
{
	return m_file;
}

DosHeader^ PE::DosHeaders::get()
{
	return m_dos_headers;
}
RichHeader^ PE::richheaders::get()
{
	return m_rich_header;
}

NtFileHeader^ PE::NtFileHeaders::get()
{
	return m_nt_file_headers;
}

NtOptionalHeader^ PE::NtOptionalHeaders::get()
{
	return m_nt_optional_headers;
}

array<DataDirectory^>^ PE::DataDirectories::get()
{
	return m_data_directories;
}

array<SectionHeader^>^ PE::SectionHeaders::get()
{
	return m_section_headers;
}

List<DllImport^>^ PE::DllImports::get()
{
	return m_dll_imports;
}
