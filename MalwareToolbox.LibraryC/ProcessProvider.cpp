#include "pch.h"

#include <cstdio>
#include <phnt_windows.h>
#include <phnt.h>
#include <Psapi.h>
#include <tlhelp32.h>

#include "processes.h"

using namespace MalwareToolbox::LibraryC::ProcessAnalysis;

Dictionary<DWORD, IProcess^>^ ProcessProvider::GetProcesses()
{
    DWORD allProcesses[1024], cbNeeded;
    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded))
    {
        return nullptr;
    }

    const DWORD cProcesses = cbNeeded / sizeof(DWORD);
    Dictionary<DWORD, IProcess^>^ processMap = gcnew Dictionary<DWORD, IProcess^>(cProcesses);

    for (int i = 0; i < cProcesses; i++)
    {
        IProcess^ process = GetProcess(allProcesses[i]);
        if (process == nullptr) continue;
        processMap->TryAdd(process->ProcessID, process);
    }

    return processMap;
}

void ProcessProvider::UpdateProcesses(Dictionary<DWORD, IProcess^>^ processMap)
{
    DWORD allProcesses[1024], cbNeeded;
    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded))
    {
        return;
    }

    const DWORD cProcesses = cbNeeded / sizeof(DWORD);
    HashSet<DWORD>^ previousIDs = gcnew HashSet<DWORD>(processMap->Keys);
    for (int i = 0; i < cProcesses; i++)
    {
        IProcess^ current_process = nullptr;
        if (!processMap->TryGetValue(allProcesses[i], current_process))
        {
            IProcess^ process = GetProcess(allProcesses[i]);
            if (process == nullptr) continue;
            processMap->TryAdd(process->ProcessID, process);
        }
        else
        {
            UpdateProcess(current_process);
            previousIDs->Remove(allProcesses[i]);
        }
    }

    for each (DWORD pid in previousIDs)
    {
        processMap->Remove(pid);
    }

    delete previousIDs;
}

IProcess^ ProcessProvider::GetProcess(DWORD processID)
{
    IProcess^ process = _CreateProcess();
    process->ProcessID = processID;

    if (!UpdateProcess(process))
	{
		delete process;
		return nullptr;
	}

    return process;
}

bool ProcessProvider::UpdateProcess(IProcess^ process)
{
    // Open Handle
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, process->ProcessID);
    if (hProcess == nullptr)
    {
        return false;
    }

    HMODULE hMod;
    DWORD cbNeeded;
    if (!EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
    {
        return false;
    }

    // Process Name
    LPWSTR lpBaseName = new TCHAR[1024];
    GetModuleBaseName(hProcess, hMod, lpBaseName, 1024);
    process->ProcessName = gcnew String(lpBaseName);

    // Process Path
    LPWSTR lpFilename = new TCHAR[1024];
    GetModuleFileNameEx(hProcess, hMod, lpFilename, 1024);
    process->ProcessPath = gcnew String(lpFilename);

    int dwLen = GetFileVersionInfoSize(lpFilename, nullptr);
    BYTE* sKey = new BYTE[dwLen];
    if (!GetFileVersionInfo(lpFilename, NULL, dwLen, sKey))
    {
        return false;
    }

    UINT cbTranslate;
    LPLANGANDCODEPAGE lpTranslate;
    if (!VerQueryValue(sKey, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
    {
        return false;
    }
	
    for (unsigned int i = 0; i < (cbTranslate / sizeof(LANGANDCODEPAGE)); i++)
    {
        WCHAR subblock[256];
        swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

        LPWSTR description;
        UINT dwBytes;
        if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes))
        {
            process->Description = gcnew String(description);
        }
    }

    process->Priority = GetPriorityClass(hProcess);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        process->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        process->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        process->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        process->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    PPROCESS_MEMORY_COUNTERS_EX pmc = new PROCESS_MEMORY_COUNTERS_EX;
    if (GetProcessMemoryInfo(hProcess, (PPROCESS_MEMORY_COUNTERS)pmc, sizeof PROCESS_MEMORY_COUNTERS_EX))
    {
        process->PrivateUsage = pmc->PrivateUsage;
    }

    DWORD dwHandleCount;
    GetProcessHandleCount(hProcess, &dwHandleCount);
    process->HandlesCount = dwHandleCount;
    process->GDIHandles = GetGuiResources(hProcess, 0); // GDI (Graphical interface handles)
    process->UserHandles = GetGuiResources(hProcess, 1); // User Handles 

    CloseHandle(hProcess);

    delete[] lpBaseName;
    delete[] lpFilename;
    delete[] sKey;
    delete lpCreationTime;
    delete lpExitTime;
    delete lpKernelTime;
    delete lpUserTime;
    delete pmc;

    return true;
}

List<Thread^>^ ProcessProvider::GetThreads(DWORD processID)
{
    HANDLE hSnapThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (!hSnapThread)
    {
        return nullptr;
    }

    PTHREADENTRY32 pte32 = new THREADENTRY32;
    pte32->dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hSnapThread, pte32))
    {
        return nullptr;
    }

    List<Thread^>^ threadList = gcnew List<Thread^>();

    do
    {
        if (processID == pte32->th32OwnerProcessID)
        {
            threadList->Add(GetThread(processID, pte32->th32ThreadID));
        }
    } while (Thread32Next(hSnapThread, pte32));

    CloseHandle(hSnapThread);

    return threadList;
}

Thread^ ProcessProvider::GetThread(DWORD processID, DWORD threadID)
{
    Thread^ thread = gcnew Thread();
	thread->ProcessID = processID;
    thread->ThreadID = threadID;

    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, threadID);
    if (hThread == nullptr)
	{
		return thread;
	}

    thread->Priority = GetThreadPriority(hThread);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetThreadTimes(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        thread->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        thread->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        thread->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        thread->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    return thread;
}
