#include "pch.h"

#include <cstdio>
#include <phnt_windows.h>
#include <phnt.h>
#include <Psapi.h>
#include <tlhelp32.h>
#include <sddl.h>
#include <strsafe.h>

#include "processes.h"

using namespace MalwareToolbox::LibraryC::ProcessAnalysis;

ProcessProvider::ProcessProvider(Func<IProcess^>^ createProcess, Func<IThread^>^ createThread)
    : _CreateProcess(createProcess),
      _CreateThread(createThread)
{
}

Dictionary<DWORD, IProcess^>^ ProcessProvider::QueryProcesses()
{
    DWORD allProcesses[1024], cbNeeded;
    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded))
    {
        return nullptr;
    }

    const DWORD cProcesses = cbNeeded / sizeof(DWORD);

    if (_ProcessCache == nullptr)
    {
        _ProcessCache = gcnew Dictionary<DWORD, IProcess^>(cProcesses);
    }

    HashSet<DWORD>^ previousIds = gcnew HashSet<DWORD>(_ProcessCache->Keys);
    for (DWORD i = 0; i < cProcesses; i++)
    {
        IProcess^ currentProcess = nullptr;
        if (!_ProcessCache->TryGetValue(allProcesses[i], currentProcess))
        {
            IProcess^ currentProcess = FetchProcess(allProcesses[i]);
            if (currentProcess == nullptr)
			{
				continue;
			}
            _ProcessCache->TryAdd(currentProcess->ProcessID, currentProcess);
        }
        else
        {
            if (!UpdateProcess(currentProcess))
            {
	            continue;
            }
            previousIds->Remove(allProcesses[i]);
        }
    }

    for each (DWORD pid in previousIds)
    {
        _ProcessCache->Remove(pid);
    }

    delete previousIds;

    return _ProcessCache;
}

IProcess^ ProcessProvider::GetProcess(DWORD processID)
{
	IProcess^ process = nullptr;
	_ProcessCache->TryGetValue(processID, process);
	return process;
}

IProcess^ ProcessProvider::FetchProcess(DWORD processID)
{
    IProcess^ process = _CreateProcess();
    process->ProcessID = processID;

    if (!UpdateProcess(process))
	{
		delete process;
		return nullptr;
	}

    return process;
}

bool ProcessProvider::UpdateProcess(IProcess^ process)
{
    // Open Handle
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, process->ProcessID);
    if (hProcess == nullptr)
    {
        return false;
    }

    // Process Name
    const LPWSTR lpBaseName = new TCHAR[MAX_PATH];
    GetModuleBaseName(hProcess, nullptr, lpBaseName, MAX_PATH);
    process->ProcessName = gcnew String(lpBaseName);

    // Process Path
    const LPWSTR lpFilename = new TCHAR[MAX_PATH];
    GetModuleFileNameEx(hProcess, nullptr, lpFilename, MAX_PATH);
    process->ProcessPath = gcnew String(lpFilename);

    const int dwLen = GetFileVersionInfoSize(lpFilename, nullptr);
    BYTE* sKey = new BYTE[dwLen];
    if (!GetFileVersionInfo(lpFilename, NULL, dwLen, sKey))
    {
        return false;
    }

    UINT cbTranslate;
    LPLANGANDCODEPAGE lpTranslate;
    if (VerQueryValue(sKey, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
    {
        for (unsigned int i = 0; i < cbTranslate / sizeof(LANGANDCODEPAGE); i++)
        {
            WCHAR subblock[256];
            swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

            LPWSTR description;
            UINT dwBytes;
            if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes))
            {
                process->Description = gcnew String(description);
            }
        }
    }

    process->Priority = GetPriorityClass(hProcess);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        process->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        process->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        process->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        process->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    const PPROCESS_MEMORY_COUNTERS_EX pmc = new PROCESS_MEMORY_COUNTERS_EX;
    if (GetProcessMemoryInfo(hProcess, reinterpret_cast<PPROCESS_MEMORY_COUNTERS>(pmc), sizeof PROCESS_MEMORY_COUNTERS_EX))
    {
        process->PageFaultCount = pmc->PageFaultCount;
        process->PeakWorkingSetSize = pmc->PeakWorkingSetSize;
        process->WorkingSetSize = pmc->WorkingSetSize;
        process->QuotaPeakPagedPoolUsage = pmc->QuotaPeakPagedPoolUsage;
        process->QuotaPagedPoolUsage = pmc->QuotaPagedPoolUsage;
        process->QuotaPeakNonPagedPoolUsage = pmc->QuotaPeakNonPagedPoolUsage;
        process->QuotaNonPagedPoolUsage = pmc->QuotaNonPagedPoolUsage;
        process->PagefileUsage = pmc->PagefileUsage;
        process->PeakPagefileUsage = pmc->PeakPagefileUsage;
        process->PrivateUsage = pmc->PrivateUsage;
    }

    ULONG64 cycleTime;
    if (QueryProcessCycleTime(hProcess, &cycleTime))
    {
        process->CycleTime = cycleTime;
    }

    const PIO_COUNTERS lpIoCounters = new IO_COUNTERS;
    if (GetProcessIoCounters(hProcess, lpIoCounters))
    {
        process->ReadOperationCount = lpIoCounters->ReadOperationCount;
        process->WriteOperationCount = lpIoCounters->WriteOperationCount;
        process->OtherOperationCount = lpIoCounters->OtherOperationCount;
        process->ReadTransferCount = lpIoCounters->ReadTransferCount;
        process->WriteTransferCount = lpIoCounters->WriteTransferCount;
        process->OtherTransferCount = lpIoCounters->OtherTransferCount;
    }

    DWORD dwHandleCount;
    if (GetProcessHandleCount(hProcess, &dwHandleCount))
    {
        process->HandlesCount = dwHandleCount;
    }
    process->GDIHandles = GetGuiResources(hProcess, 0); // GDI (Graphical interface handles)
    process->UserHandles = GetGuiResources(hProcess, 1); // User Handles

    if (process->DoThreadsLoad) QueryThreads(process);

    CloseHandle(hProcess);

    delete[] lpBaseName;
    delete[] lpFilename;
    delete[] sKey;
    delete lpCreationTime;
    delete lpExitTime;
    delete lpKernelTime;
    delete lpUserTime;
    delete pmc;
    delete lpIoCounters;

    return true;
}

Dictionary<DWORD, IThread^>^ ProcessProvider::QueryThreads(DWORD processID)
{
    IProcess^ process = nullptr;
    if (!_ProcessCache->TryGetValue(processID, process))
    {
        return nullptr;
    }

    return QueryThreads(process);
}

Dictionary<DWORD, IThread^>^ ProcessProvider::QueryThreads(IProcess^ process)
{
    if (process->Threads == nullptr)
    {
        process->Threads = gcnew Dictionary<DWORD, IThread^>();
    }

    const HANDLE hSnapThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (!hSnapThread)
    {
        return process->Threads;
    }

    PTHREADENTRY32 pte32 = new THREADENTRY32;
    pte32->dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hSnapThread, pte32))
    {
        return process->Threads;
    }

    HashSet<DWORD>^ previousIds = gcnew HashSet<DWORD>(process->Threads->Keys);
    do
    {
        if (process->ProcessID != pte32->th32OwnerProcessID) continue;

        IThread^ currentThread = nullptr;
        if (!process->Threads->TryGetValue(pte32->th32ThreadID, currentThread))
        {
            currentThread = FetchThread(process->ProcessID, pte32->th32ThreadID);
            if (currentThread == nullptr)
            {
                continue;
            }
            process->Threads->TryAdd(currentThread->ThreadID, currentThread);
        }
        else
        {
            if (!UpdateThread(currentThread))
            {
                continue;
            }
            previousIds->Remove(currentThread->ThreadID);
        }

    } while (Thread32Next(hSnapThread, pte32));

    for each (DWORD pid in previousIds)
    {
        process->Threads->Remove(pid);
    }

    CloseHandle(hSnapThread);

    return process->Threads;
}

IThread^ ProcessProvider::GetThread(DWORD processID, DWORD threadID)
{
    IProcess^ process = GetProcess(processID);
    if (process != nullptr)
    {
	    IThread^ thread = nullptr;
        process->Threads->TryGetValue(threadID, thread);
        return thread;
    }

    return nullptr;
}

IThread^ ProcessProvider::FetchThread(DWORD processID, DWORD threadID)
{
    IThread^ thread = _CreateThread();
	thread->ProcessID = processID;
    thread->ThreadID = threadID;

    if (!UpdateThread(thread))
    {
        delete thread;
		return nullptr;
    }

    return thread;
}

bool ProcessProvider::UpdateThread(IThread^ thread)
{
	const HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, thread->ThreadID);
    if (hThread == nullptr)
    {
        return false;
    }

    thread->Priority = GetThreadPriority(hThread);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetThreadTimes(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        thread->CreationTime = Utils::Converters::filetime_to_datetime(*lpCreationTime);
        thread->ExitTime = Utils::Converters::filetime_to_datetime(*lpExitTime);
        thread->KernelTime = Utils::Converters::filetime_to_timespan(*lpKernelTime);
        thread->UserTime = Utils::Converters::filetime_to_timespan(*lpUserTime);
    }

    ULONG64 cycleTime;
    if (QueryThreadCycleTime(hThread, &cycleTime))
    {
	    thread->CycleTime = cycleTime;
    }

    CloseHandle(hThread);

    delete lpCreationTime;
    delete lpExitTime;
    delete lpKernelTime;
    delete lpUserTime;

    return true;
}

List<Module^>^ ProcessProvider::QueryModules(IProcess^ process)
{
    //todo cache in process property

    List<Module^>^ modules = gcnew List<Module^>();

    // Open Handle
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, process->ProcessID);
    if (hProcess == nullptr)
    {
        return modules;
    }

    HMODULE lphModule[1024];
	DWORD cbNeeded;
	if (!EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &cbNeeded))
	{
	    return modules;
	}

    const DWORD cModules = cbNeeded / sizeof(HMODULE);
    for (DWORD i = 0; i < cModules; i++)
    {
        Module^ module = gcnew Module();

        // Process Name
        const LPWSTR lpBaseName = new TCHAR[MAX_PATH];
        GetModuleBaseName(hProcess, lphModule[i], lpBaseName, MAX_PATH);
        module->Name = gcnew String(lpBaseName);

        // Process Path
        const LPWSTR lpFilename = new TCHAR[MAX_PATH];
        GetModuleFileNameEx(hProcess, lphModule[i], lpFilename, MAX_PATH);
        module->Path = gcnew String(lpFilename);

        const int dwLen = GetFileVersionInfoSize(lpFilename, nullptr);
        BYTE* sKey = new BYTE[dwLen];
        if (!GetFileVersionInfo(lpFilename, NULL, dwLen, sKey))
        {
            continue;
        }

        UINT cbTranslate;
        LPLANGANDCODEPAGE lpTranslate;
        if (VerQueryValue(sKey, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
        {
            for (unsigned int i = 0; i < cbTranslate / sizeof(LANGANDCODEPAGE); i++)
            {
                WCHAR subblock[256];
                swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

                LPWSTR description;
                UINT dwBytes;
                if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes))
                {
                    module->Description = gcnew String(description);
                }
            }
        }

        modules->Add(module);

        delete[] lpBaseName;
        delete[] lpFilename;
        delete[] sKey;
    }

    CloseHandle(hProcess);

    return modules;
}

Token^ ProcessProvider::QueryToken(IProcess^ process)
{
    Token^ token = gcnew Token();

	// Open Handle
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, process->ProcessID);
    if (hProcess == nullptr)
    {
        return token;
    }

    HANDLE hToken;
    if (!OpenProcessToken(hProcess, TOKEN_ALL_ACCESS, &hToken))
    {
        return token;
    }

    const PTOKEN_USER tokenUser = (PTOKEN_USER)QueryTokenInfo(hToken, TokenUser);
    if (tokenUser != nullptr)
    {
        token->User = LoadAccount(tokenUser->User);
        VirtualFree(tokenUser, 0x0, MEM_RELEASE);
    }

    const PTOKEN_OWNER tokenOwner = (PTOKEN_OWNER)QueryTokenInfo(hToken, TokenOwner);
    if (tokenOwner != nullptr)
	{
		token->Owner = LoadAccount(tokenOwner->Owner);
        VirtualFree(tokenOwner, 0x0, MEM_RELEASE);
	}

    const PTOKEN_PRIMARY_GROUP tokenPrimaryGroup = (PTOKEN_PRIMARY_GROUP)QueryTokenInfo(hToken, TokenPrimaryGroup);
    if (tokenPrimaryGroup != nullptr)
    {
        token->PrimaryGroup = LoadAccount(tokenPrimaryGroup->PrimaryGroup);
        VirtualFree(tokenPrimaryGroup, 0x0, MEM_RELEASE);
    }

    const LPDWORD lpSessionId = (LPDWORD)QueryTokenInfo(hToken, TokenSessionId);
    if (lpSessionId != nullptr)
	{
		token->SessionId = *lpSessionId;
        VirtualFree(lpSessionId, 0x0, MEM_RELEASE);
	}

    PTOKEN_ELEVATION tokenElevation = (PTOKEN_ELEVATION)QueryTokenInfo(hToken, TokenElevation);
    if (tokenElevation != nullptr)
    {
        token->IsElevated = tokenElevation->TokenIsElevated;
        VirtualFree(tokenElevation, 0x0, MEM_RELEASE);
	}

    PTOKEN_ELEVATION_TYPE tokenElevationType = (PTOKEN_ELEVATION_TYPE)QueryTokenInfo(hToken, TokenElevationType);
    if (tokenElevationType != nullptr)
    {
        token->ElevationType = Utils::Converters::elevationtype_tostring(*tokenElevationType);
        VirtualFree(tokenElevationType, 0x0, MEM_RELEASE);
    }

    const LPDWORD lpVirtualizationAllowed = (LPDWORD)QueryTokenInfo(hToken, TokenVirtualizationAllowed);
    if (lpVirtualizationAllowed != nullptr)
    {
        if (*lpVirtualizationAllowed)
        {
            const LPDWORD lpVirtualizationEnabled = (LPDWORD)QueryTokenInfo(hToken, TokenVirtualizationEnabled);
            if (lpVirtualizationEnabled != nullptr)
			{
                token->VirtualizationEnabled = *lpVirtualizationEnabled;
				VirtualFree(lpVirtualizationEnabled, 0x0, MEM_RELEASE);
			}
        }

        token->VirtualizationAllowed = *lpVirtualizationAllowed;
        VirtualFree(lpVirtualizationAllowed, 0x0, MEM_RELEASE);
    }

    const PTOKEN_GROUPS tokenGroups = (PTOKEN_GROUPS)QueryTokenInfo(hToken, TokenGroups);
    if (tokenGroups != nullptr)
	{
        token->Groups = gcnew List<Account^>(tokenGroups->GroupCount);
        for (DWORD c = 0; c < tokenGroups->GroupCount; c++)
        {
            token->Groups->Add(LoadAccount(tokenGroups->Groups[c]));
        }
		VirtualFree(tokenGroups, 0x0, MEM_RELEASE);
	}

    const PTOKEN_PRIVILEGES tokenPrivileges = (PTOKEN_PRIVILEGES)QueryTokenInfo(hToken, TokenPrivileges);
    if (tokenPrivileges != nullptr)
    {
        token->Privileges = gcnew List<TokenPrivilege^>(tokenPrivileges->PrivilegeCount);
        for (DWORD c = 0; c < tokenPrivileges->PrivilegeCount; c++)
		{
            LUID_AND_ATTRIBUTES laa = tokenPrivileges->Privileges[c];
            TokenPrivilege^ privilege = gcnew TokenPrivilege();

            privilege->Attributes = laa.Attributes;

            LPWSTR lpName = (LPWSTR)VirtualAlloc(nullptr, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            LPWSTR lpDisplayName = (LPWSTR)VirtualAlloc(nullptr, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            DWORD dwName, dwLangId, dwDisplayName;
            dwName = dwDisplayName = 1024;

            if (LookupPrivilegeNameW(nullptr, &laa.Luid, lpName, &dwName))
            {
                privilege->Name = gcnew String(lpName);
            }

            if (LookupPrivilegeDisplayNameW(nullptr, lpName, lpDisplayName, &dwDisplayName, &dwLangId))
			{
				privilege->Description = gcnew String(lpDisplayName);
			}

			token->Privileges->Add(privilege);

            VirtualFree(lpName, 0x0, MEM_RELEASE);
            VirtualFree(lpDisplayName, 0x0, MEM_RELEASE);
		}
        VirtualFree(tokenPrivileges, 0x0, MEM_RELEASE);
    }

    const PTOKEN_STATISTICS tokenStatistics = (PTOKEN_STATISTICS)QueryTokenInfo(hToken, TokenStatistics);
    if (tokenStatistics != nullptr)
    {
        token->TokenId = Utils::Converters::twoint32_to_int64(tokenStatistics->TokenId.HighPart, tokenStatistics->TokenId.LowPart);
        token->AuthenticationId = Utils::Converters::twoint32_to_int64(tokenStatistics->AuthenticationId.HighPart, tokenStatistics->AuthenticationId.LowPart);
	    token->ExpirationTime = tokenStatistics->ExpirationTime.QuadPart;
        token->TokenType = Utils::Converters::tokentype_tostring(tokenStatistics->TokenType);
        token->ImpersonationLevel = Utils::Converters::sectype_tostring(tokenStatistics->ImpersonationLevel);
        token->DynamicCharged = tokenStatistics->DynamicCharged;
        token->DynamicAvailable = tokenStatistics->DynamicAvailable;
        token->GroupCount = tokenStatistics->GroupCount;
        token->PrivilegeCount = tokenStatistics->PrivilegeCount;
        token->ModifiedId = Utils::Converters::twoint32_to_int64(tokenStatistics->ModifiedId.HighPart, tokenStatistics->ModifiedId.LowPart);

        VirtualFree(tokenStatistics, 0x0, MEM_RELEASE);
    }

    const PTOKEN_SOURCE tokenSource = (PTOKEN_SOURCE)QueryTokenInfo(hToken, TokenSource);
    if (tokenSource != nullptr)
	{
		token->SourceName = gcnew String(tokenSource->SourceName);
        token->SourceIdentifier = Utils::Converters::twoint32_to_int64(tokenSource->SourceIdentifier.HighPart, tokenSource->SourceIdentifier.LowPart); 

		VirtualFree(tokenSource, 0x0, MEM_RELEASE);
	}

    LPDWORD lpHasRestrictions = (LPDWORD)QueryTokenInfo(hToken, TokenHasRestrictions);
	if (lpHasRestrictions != nullptr)
	{
		token->HasRestrictions = *lpHasRestrictions;
		VirtualFree(lpHasRestrictions, 0x0, MEM_RELEASE);
	}

    LPDWORD lpSandBoxInert = (LPDWORD)QueryTokenInfo(hToken, TokenSandBoxInert);
    if (lpSandBoxInert != nullptr)
	{
		token->SandBoxInert = *lpSandBoxInert;
		VirtualFree(lpSandBoxInert, 0x0, MEM_RELEASE);
	}

    CloseHandle(hToken);
    CloseHandle(hProcess);

    return token;
}

PVOID ProcessProvider::QueryTokenInfo(HANDLE hToken, TOKEN_INFORMATION_CLASS tokenClass)
{
    DWORD dwDataLen = 0x0;
    GetTokenInformation(hToken, tokenClass, nullptr, 0x0, &dwDataLen);

    PVOID tokenData = VirtualAlloc(nullptr, dwDataLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

    DWORD dwReturnLen;
    if (!GetTokenInformation(hToken, tokenClass, tokenData, dwDataLen, &dwReturnLen))
    {
        VirtualFree(tokenData, 0x0, MEM_RELEASE);
        tokenData = nullptr;
    }

    return tokenData;
}

Account^ ProcessProvider::LoadAccount(SID_AND_ATTRIBUTES user)
{
    Account^ account = LoadAccount(user.Sid);
    account->Attributes = user.Attributes;
    return account;
}

Account^ ProcessProvider::LoadAccount(PSID sid)
{
	Account^ account = gcnew Account();


	LPWSTR lpSid;
    ConvertSidToStringSidW(sid, &lpSid);
    account->Sid = gcnew String(lpSid);

	const LPWSTR lpAccountName = new WCHAR[MAX_PATH];
	const LPWSTR lpDomainName = new WCHAR[MAX_PATH];
    SID_NAME_USE eSidType;
    DWORD dwAccount = MAX_PATH;
    DWORD dwDomain = MAX_PATH;
    if (LookupAccountSidW(nullptr, sid, lpAccountName, &dwAccount, lpDomainName, &dwDomain, &eSidType))
    {
	    account->Name = gcnew String(lpAccountName);
        account->Domain = gcnew String(lpDomainName);
        account->SidType = Utils::Converters::sidtype_tostring(eSidType);
    }

    delete[] lpAccountName;
    delete[] lpDomainName;

    return account;
}
