#include "pch.h"

#include <cstdio>
#include <phnt_windows.h>
#include <phnt.h>
#include <Psapi.h>
#include <tlhelp32.h>

#include "processes.h"

using namespace MalwareToolbox::LibraryC::ProcessAnalysis;

array<Process^>^ ProcessProvider::GetProcesses()
{
    DWORD allProcesses[1024], cbNeeded;
    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded))
    {
        return nullptr;
    }

    const DWORD cProcesses = cbNeeded / sizeof(DWORD);
    array<Process^>^ processArray = gcnew array<Process^>(cProcesses);

    for (int i = 0; i < cProcesses; i++)
    {
        processArray[i] = GetProcess(allProcesses[i]);
    }

    return processArray;
}

Process^ ProcessProvider::GetProcess(DWORD processID)
{
    Process^ process = gcnew Process();
    process->ProcessID = processID;

    // Open Handle
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);
    if (hProcess == nullptr)
    {
        return process;
    }

    HMODULE hMod;
    DWORD cbNeeded;
    if (!EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
    {
        return process;
    }

    // Process Name
    LPWSTR lpBaseName = new TCHAR[1024];
    GetModuleBaseName(hProcess, hMod, lpBaseName, 1024);
    process->ProcessName = gcnew String(lpBaseName);

    // Process Path
    LPWSTR lpFilename = new TCHAR[1024];
    GetModuleFileNameEx(hProcess, hMod, lpFilename, 1024);
    process->ProcessPath = gcnew String(lpFilename);

    int dwLen = GetFileVersionInfoSize(lpFilename, nullptr);
	BYTE* sKey = new BYTE[dwLen];
    if (!GetFileVersionInfo(lpFilename, NULL, dwLen, sKey))
    {
        return process;
    }

    UINT cbTranslate;
    LPLANGANDCODEPAGE lpTranslate;
    if (!VerQueryValue(sKey, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
    {
        return process;
    }
	
    for (unsigned int i = 0; i < (cbTranslate / sizeof(LANGANDCODEPAGE)); i++)
    {
        WCHAR subblock[256];
        swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

        LPWSTR description;
        UINT dwBytes;
        if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes))
        {
	        process->Description = gcnew String(description);
        }
    }

    process->Priority = GetPriorityClass(hProcess);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        process->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        process->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        process->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        process->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    PPROCESS_MEMORY_COUNTERS_EX pmc = new PROCESS_MEMORY_COUNTERS_EX;
    if (GetProcessMemoryInfo(hProcess, (PPROCESS_MEMORY_COUNTERS)pmc, sizeof PROCESS_MEMORY_COUNTERS_EX))
    {
	    
    }

    DWORD dwHandleCount;
    GetProcessHandleCount(hProcess, &dwHandleCount);
    DWORD gdiHandleCount = GetGuiResources(hProcess, 0); // GDI (Graphical interface handles)
    DWORD userHandleCount = GetGuiResources(hProcess, 1); // User Handles 

    CloseHandle(hProcess);

    return process;
}

List<Thread^>^ ProcessProvider::GetThreads(DWORD processID)
{
    HANDLE hSnapThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (!hSnapThread)
    {
        return nullptr;
    }

    PTHREADENTRY32 pte32 = new THREADENTRY32;
    pte32->dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hSnapThread, pte32))
    {
        return nullptr;
    }

    List<Thread^>^ threadList = gcnew List<Thread^>();

    do
    {
        if (processID == pte32->th32OwnerProcessID)
        {
            threadList->Add(GetThread(processID, pte32->th32ThreadID));
        }
    } while (Thread32Next(hSnapThread, pte32));

    CloseHandle(hSnapThread);

    return threadList;
}

Thread^ ProcessProvider::GetThread(DWORD processID, DWORD threadID)
{
    Thread^ thread = gcnew Thread();
	thread->ProcessID = processID;
    thread->ThreadID = threadID;

    HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, threadID);
    if (hThread == nullptr)
	{
		return thread;
	}

    thread->Priority = GetThreadPriority(hThread);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetThreadTimes(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        thread->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        thread->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        thread->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        thread->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    return thread;
}
