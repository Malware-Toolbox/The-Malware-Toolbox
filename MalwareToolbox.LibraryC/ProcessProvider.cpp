#include "pch.h"

#include <cstdio>
#include <phnt_windows.h>
#include <phnt.h>
#include <Psapi.h>

#include "processes.h"


using namespace MalwareToolbox::LibraryC::ProcessAnalysis;

DWORD Process::ProcessID::get()
{
    return _ProcessID;
}

void Process::ProcessID::set(DWORD value)
{
    _ProcessID = value;
}

String^ Process::ProcessName::get()
{
    return _ProcessName;
}

void Process::ProcessName::set(String^ value)
{
    _ProcessName = value;
}

String^ Process::ProcessPath::get()
{
	return _ProcessPath;
}

void Process::ProcessPath::set(String^ value)
{
    _ProcessPath = value;
}

String^ Process::Description::get()
{
	return _Description;
}

void Process::Description::set(String^ value)
{
    _Description = value;
}

array<Process^>^ ProcessProvider::GetProcesses()
{
    DWORD allProcesses[1024], cbNeeded;
    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded))
    {
        return nullptr;
    }

    const DWORD cProcesses = cbNeeded / sizeof(DWORD);
    array<Process^>^ processArray = gcnew array<Process^>(cProcesses);

    for (int i = 0; i < cProcesses; i++)
    {
        processArray[i] = GetProcess(allProcesses[i]);
    }

    return processArray;
}

Process^ ProcessProvider::GetProcess(DWORD processID)
{
    Process^ p = gcnew Process();
    p->ProcessID = processID;

    //try get openprocess in a void func then use that value to initialise class
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processID);
    if (hProcess == nullptr)
    {
        return p;
    }

    HMODULE hMod;
    DWORD cbNeeded;
    if (!EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
    {
        return p;
    }

    LPWSTR szProcessName = new TCHAR[1024];
    GetModuleBaseName(hProcess, hMod, szProcessName, 1024);
    p->ProcessName = gcnew String(szProcessName);
    delete szProcessName;

    // LPWSTR lpImageFileName = new TCHAR[1024];
    // GetProcessImageFileName(hProcess, lpImageFileName, 1024);

    LPWSTR fileName = new TCHAR[1024];
    GetModuleFileNameEx(hProcess, hMod, fileName, 1024);
    p->ProcessPath = gcnew String(fileName);
    delete fileName;

    int dwLen = GetFileVersionInfoSize(fileName, nullptr);
	BYTE* sKey = new BYTE[dwLen];
    if (!GetFileVersionInfo(fileName, NULL, dwLen, sKey))
    {
        return p;
    }

    UINT cbTranslate;
    LPLANGANDCODEPAGE lpTranslate;
    if (!VerQueryValue(sKey, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
    {
        return p;
    }
	
    for (unsigned int i = 0; i < (cbTranslate / sizeof(LANGANDCODEPAGE)); i++)
    {
        WCHAR subblock[256];
        swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

        LPWSTR description;
        UINT dwBytes;
        if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes))
        {
	        p->Description = gcnew String(description);
        }
        delete description;
    }
    delete lpTranslate;
    delete sKey;

    CloseHandle(hProcess);

    return p;
}
