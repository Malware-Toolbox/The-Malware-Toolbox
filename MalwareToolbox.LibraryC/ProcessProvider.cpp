#include "pch.h"

#include <cstdio>
#include <phnt_windows.h>
#include <phnt.h>
#include <Psapi.h>
#include <tlhelp32.h>

#include "processes.h"

using namespace MalwareToolbox::LibraryC::ProcessAnalysis;

ProcessProvider::ProcessProvider(Func<IProcess^>^ createProcess, Func<IThread^>^ createThread)
    : _CreateProcess(createProcess),
      _CreateThread(createThread)
{
}

Dictionary<DWORD, IProcess^>^ ProcessProvider::GetProcesses()
{
    DWORD allProcesses[1024], cbNeeded;
    if (!EnumProcesses(allProcesses, sizeof(allProcesses), &cbNeeded))
    {
        return nullptr;
    }

    const DWORD cProcesses = cbNeeded / sizeof(DWORD);

    if (_ProcessCache == nullptr)
    {
        _ProcessCache = gcnew Dictionary<DWORD, IProcess^>(cProcesses);
    }

    HashSet<DWORD>^ previousIds = gcnew HashSet<DWORD>(_ProcessCache->Keys);
    for (int i = 0; i < cProcesses; i++)
    {
        IProcess^ currentProcess = nullptr;
        if (!_ProcessCache->TryGetValue(allProcesses[i], currentProcess))
        {
            IProcess^ currentProcess = LoadProcess(allProcesses[i]);
            if (currentProcess == nullptr)
			{
				continue;
			}
            _ProcessCache->TryAdd(currentProcess->ProcessID, currentProcess);
        }
        else
        {
            if (!UpdateProcess(currentProcess))
            {
	            continue;
            }
            previousIds->Remove(allProcesses[i]);
        }
        //GetThreads(allProcesses[i]);
    }

    for each (DWORD pid in previousIds)
    {
        _ProcessCache->Remove(pid);
    }

    delete previousIds;

    return _ProcessCache;
}

IProcess^ ProcessProvider::LoadProcess(DWORD processID)
{
    IProcess^ process = _CreateProcess();
    process->ProcessID = processID;

    if (!UpdateProcess(process))
	{
		delete process;
		return nullptr;
	}

    return process;
}

IProcess^ ProcessProvider::GetProcess(DWORD processID)
{
    IProcess^ process = nullptr;
    _ProcessCache->TryGetValue(processID, process);
    return process;
}

bool ProcessProvider::UpdateProcess(IProcess^ process)
{
    // Open Handle
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, process->ProcessID);
    if (hProcess == nullptr)
    {
        return false;
    }

    HMODULE hMod;
    DWORD cbNeeded;
    if (!EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded))
    {
        return false;
    }

    // Process Name
    LPWSTR lpBaseName = new TCHAR[1024];
    GetModuleBaseName(hProcess, hMod, lpBaseName, 1024);
    process->ProcessName = gcnew String(lpBaseName);

    // Process Path
    LPWSTR lpFilename = new TCHAR[1024];
    GetModuleFileNameEx(hProcess, hMod, lpFilename, 1024);
    process->ProcessPath = gcnew String(lpFilename);

    int dwLen = GetFileVersionInfoSize(lpFilename, nullptr);
    BYTE* sKey = new BYTE[dwLen];
    if (!GetFileVersionInfo(lpFilename, NULL, dwLen, sKey))
    {
        return false;
    }

    UINT cbTranslate;
    LPLANGANDCODEPAGE lpTranslate;
    if (VerQueryValue(sKey, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
    {
        for (unsigned int i = 0; i < cbTranslate / sizeof(LANGANDCODEPAGE); i++)
        {
            WCHAR subblock[256];
            swprintf_s(subblock, L"\\StringFileInfo\\%04x%04x\\FileDescription", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

            LPWSTR description;
            UINT dwBytes;
            if (VerQueryValue(sKey, subblock, (LPVOID*)&description, &dwBytes))
            {
                process->Description = gcnew String(description);
            }
        }
    }

    process->Priority = GetPriorityClass(hProcess);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        process->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        process->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        process->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        process->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    PPROCESS_MEMORY_COUNTERS_EX pmc = new PROCESS_MEMORY_COUNTERS_EX;
    if (GetProcessMemoryInfo(hProcess, (PPROCESS_MEMORY_COUNTERS)pmc, sizeof PROCESS_MEMORY_COUNTERS_EX))
    {
        process->PrivateUsage = pmc->PrivateUsage;
    }

    DWORD dwHandleCount;
    GetProcessHandleCount(hProcess, &dwHandleCount);
    process->HandlesCount = dwHandleCount;
    process->GDIHandles = GetGuiResources(hProcess, 0); // GDI (Graphical interface handles)
    process->UserHandles = GetGuiResources(hProcess, 1); // User Handles

    if (process->DoThreadsLoad) GetThreads(process);

    CloseHandle(hProcess);

    delete[] lpBaseName;
    delete[] lpFilename;
    delete[] sKey;
    delete lpCreationTime;
    delete lpExitTime;
    delete lpKernelTime;
    delete lpUserTime;
    delete pmc;

    return true;
}

Dictionary<DWORD, IThread^>^ ProcessProvider::GetThreads(DWORD processID)
{
    IProcess^ process = nullptr;
    if (!_ProcessCache->TryGetValue(processID, process))
    {
        return nullptr;
    }

    return GetThreads(process);
}

Dictionary<DWORD, IThread^>^ ProcessProvider::GetThreads(IProcess^ process)
{
    if (process->Threads == nullptr)
    {
        process->Threads = gcnew Dictionary<DWORD, IThread^>();
    }

    const HANDLE hSnapThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (!hSnapThread)
    {
        return process->Threads;
    }

    PTHREADENTRY32 pte32 = new THREADENTRY32;
    pte32->dwSize = sizeof(THREADENTRY32);

    if (!Thread32First(hSnapThread, pte32))
    {
        return process->Threads;
    }

    HashSet<DWORD>^ previousIds = gcnew HashSet<DWORD>(process->Threads->Keys);
    do
    {
        if (process->ProcessID != pte32->th32OwnerProcessID) continue;

        IThread^ currentThread = nullptr;
        if (!process->Threads->TryGetValue(pte32->th32ThreadID, currentThread))
        {
            currentThread = GetThread(process->ProcessID, pte32->th32ThreadID);
            if (currentThread == nullptr)
            {
                continue;
            }
            process->Threads->TryAdd(currentThread->ThreadID, currentThread);
        }
        else
        {
            UpdateThread(currentThread);
        }

    } while (Thread32Next(hSnapThread, pte32));

    for each (DWORD pid in previousIds)
    {
        process->Threads->Remove(pid);
    }

    CloseHandle(hSnapThread);

    return process->Threads;
}

IThread^ ProcessProvider::GetThread(DWORD processID, DWORD threadID)
{
    IThread^ thread = _CreateThread();
	thread->ProcessID = processID;
    thread->ThreadID = threadID;

    if (!UpdateThread(thread))
    {
        delete thread;
		return nullptr;
    }

    return thread;
}

bool ProcessProvider::UpdateThread(IThread^ thread)
{
	const HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, TRUE, thread->ThreadID);
    if (hThread == nullptr)
    {
        return false;
    }

    thread->Priority = GetThreadPriority(hThread);

    const LPFILETIME lpCreationTime = new FILETIME;
    const LPFILETIME lpExitTime = new FILETIME;
    const LPFILETIME lpKernelTime = new FILETIME;
    const LPFILETIME lpUserTime = new FILETIME;
    if (GetThreadTimes(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime))
    {
        thread->CreationTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpCreationTime->dwHighDateTime, lpCreationTime->dwLowDateTime));
        thread->ExitTime = DateTime::FromFileTime(Utils::Converters::twoint32_to_int64(lpExitTime->dwHighDateTime, lpExitTime->dwLowDateTime));
        thread->KernelTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpKernelTime->dwHighDateTime, lpKernelTime->dwLowDateTime));
        thread->UserTime = TimeSpan::FromTicks(Utils::Converters::twoint32_to_int64(lpUserTime->dwHighDateTime, lpUserTime->dwLowDateTime));
    }

    CloseHandle(hThread);

    delete lpCreationTime;
    delete lpExitTime;
    delete lpKernelTime;
    delete lpUserTime;

    return true;
}
