#pragma once
#include "Utils.h"

using namespace Collections::Generic;
using namespace Text::RegularExpressions;

namespace MalwareToolbox {
	namespace LibraryC {
		namespace Strings
		{
			public enum class StringsDuplicateMode
			{
				Keep,
				RemoveCaseSensitive,
				RemoveCaseInSensitive
			};

			public enum class StringsMatchingMode
			{
				Contains,
				StartsWith,
				EndsWith,
				Exact
			};

			public enum class StringsSortOrder
			{
				Default,
				Alphabetical,
				Length
			};

			public enum class StringsSortDirection
			{
				Ascending,
				Descending
			};

			public ref struct StringItem
			{
				StringItem(String^ category, String^ value)
					: Category(category),
					  Value(value)
				{
				}

				String^ Category;
				String^ Value;
			};

			public ref struct StringFilter
			{
				StringFilter(int minLength, int maxLength, String^ search, StringsMatchingMode^ matchingMode, bool caseSensitive, StringsSortOrder^ sortOrder, StringsSortDirection^ sortDirection)
					: MinLength(minLength),
					  MaxLength(maxLength),
					  Search(search),
					  MatchingMode(matchingMode),
					  CaseSensitive(caseSensitive),
					  SortOrder(sortOrder),
				      SortDirection(sortDirection)
				{
				}

				int MinLength;
				int MaxLength;
				String^ Search;
				StringsMatchingMode^ MatchingMode;
				bool CaseSensitive;
				StringsSortOrder^ SortOrder;
				StringsSortDirection^ SortDirection;
			};

			public delegate String^ StringCategoryMatcher(String^ str);

			public ref class StringCategoriser
			{
			public:
				static String^ DefaultCategory = "Others";

				StringCategoriser();

				void AddDefaultMatches();
				void AddExactMatch(String^ categoryName, String^ matchString);
				void AddRegexMatch(String^ categoryName, String^ matchRegex);
				void AddCustomMatch(StringCategoryMatcher^ customMatcher);
				Dictionary<String^, List<String^>^>^ CategoriseStrings(List<String^>^ strings);
				String^ GetCategory(String^ str);

			private:
				Dictionary<String^, String^>^ m_exact_match_map;
				List<Tuple<String^, Regex^>^>^ m_regex_match_list;
				List<StringCategoryMatcher^>^ m_custom_match_list;
			};

			public ref class StringAnalyser
			{
			public:
				StringAnalyser(Utils::WinFile^ file);

				void GenerateStrings();
				Dictionary<String^, List<String^>^>^ GetStrings(StringFilter^ filter);

			private:
				Utils::WinFile^ m_file;
				StringCategoriser m_categoriser;
				List<StringItem^>^ m_strings;
			};
		}
	}
}
