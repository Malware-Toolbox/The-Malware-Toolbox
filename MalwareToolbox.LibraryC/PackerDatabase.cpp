#include "pch.h"
#include "Unpackers.h"

#include <string>
#include <functional>
#include <iostream>
#include <map>

using namespace MalwareToolbox::LibraryC::Unpackers;

#define SIGFIELD		"signature = "
#define SIGFIELD_LEN	sizeof(SIGFIELD) - 1	// minus 1 because sizeof() counts null
#define EPFIELD_TRUE	"ep_only = true"
#define EPFIELD_FALSE	"ep_only = false"

const std::map<char, unsigned char> CHAR_TO_NUM = {
	{'0', 0x00},
	{'1', 0x01},
	{'2', 0x02},
	{'3', 0x03},
	{'4', 0x04},
	{'5', 0x05},
	{'6', 0x06},
	{'7', 0x07},
	{'8', 0x08},
	{'9', 0x09},
	{'A', 0x0A},
	{'B', 0x0B},
	{'C', 0x0C},
	{'D', 0x0D},
	{'E', 0x0E},
	{'F', 0x0F},
};

String^ get_line_from_mem(LPVOID& head, LPVOID tail)
{
	char* line = NULL;
	DWORD64 size_limit = (DWORD64)tail - (DWORD64)head;
	int i = 1, str_len = 0;
	BYTE letter = *(BYTE*)head;
	while ((letter == '\r' || letter == '\n' || letter == '\0' || letter == EOF || letter < 0x20 || letter > 0x7E) && (i < size_limit))
	{
		letter = *((BYTE*)head + i++);
	}

	for (; i < size_limit; i++)
	{
		if (letter == '\r' || letter == '\n' || letter == '\0' || letter == EOF) break;
		str_len++;
		letter = *((BYTE*)head + i);
	}

	if (letter == EOF || letter == 0) head = tail;
	head = (LPVOID)((DWORD64)head + i);

	if (str_len)
	{
		line = new char[str_len + 1];
		memcpy(line, (LPVOID)((DWORD64)head - str_len - 1), str_len);
		line[str_len] = '\0';
		String^ str = gcnew String(line);
		delete[] line;
		return str;
	}
	return "";
}

PackerDatabase::PackerDatabase(String^ filePath) : File(filePath)
{
	m_signatures = gcnew List<Signature>();
}

void PackerDatabase::PreprocessSignature(String^ line, Signature* signature)
{
	signature->SignatureValues = gcnew List<Byte>();
	signature->SignatureWildCards = gcnew List<Byte>();

	BYTE sbyte = NULL;
	BYTE wbyte = NULL;

	//step1 --- convert every two characters to one byte, and convert every '?' to F and mark the wildcard in WildCardMap
	for (unsigned int i = 0; i < line->Length; i++)
	{
		if (isspace(line[i])) continue;

		sbyte = 0;
		wbyte = 0;

		for (int j = 0; j < 2; j++)
		{
			sbyte = sbyte << 4;
			wbyte = wbyte << 4;

			if (((i + j) < line->Length) && !isspace(line[i + j]) && (line[i + j] != '?'))
			{
				sbyte |= CHAR_TO_NUM.at(line[i + j]);
				wbyte &= 0xF0;
			}
			else
			{
				// half nibble wildcard or, space at the end of file treated as '?'
				sbyte |= 0x0F;
				wbyte |= 0x0F;
			}
		}

		i++;

		signature->SignatureValues->Add(sbyte);
		signature->SignatureWildCards->Add(wbyte);
	}
}

bool PackerDatabase::Load()
{
	if (!File::Load()) return false;

	bool failure = false;
	LPVOID head = m_file_data;
	LPVOID tail = (LPVOID)((DWORD64)m_file_data + m_file_size);

	while ((head < tail) && !failure)
	{
		String^ line = nullptr;

		line = get_line_from_mem(head, tail);
		if (line->Length == 0 || line->StartsWith(';')) continue;

		Signature signature = {};
		signature.Tool = line;

		line = get_line_from_mem(head, tail);
		line = line->Trim();
		if (line->Length == 0 || line->StartsWith(';')) continue;

		if (!line->StartsWith(SIGFIELD))
		{
			std::cout << "Failed to load signature: "  << Utils::Converters::cpp_string_to_schar(signature.Tool) << std::endl; //TODO remove
			failure = true;
			continue;
		}

		PreprocessSignature(line->Substring(SIGFIELD_LEN), &signature);

		line = get_line_from_mem(head, tail);
		line = line->Trim();
		if (line == EPFIELD_TRUE) signature.IsEP = true;
		else if (line == EPFIELD_FALSE) signature.IsEP = false;
		else
		{
			std::cout << "Invalid ep property: " << Utils::Converters::cpp_string_to_schar(line) << std::endl; //TODO remove
			failure = true;
			continue;
		}

		m_signatures->Add(signature);
	}

	if (failure) return m_loaded = false;
	return m_loaded = true;
}

List<Signature>^ PackerDatabase::GetSignatures()
{
	return m_signatures;
}
