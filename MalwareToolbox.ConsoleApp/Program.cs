using System.Reflection;
using CommandLine;
using MalwareToolbox.ConsoleApp;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using MalwareToolbox.LibraryC.Unpackers;
using MalwareToolbox.LibraryC.Dynamic;

// var packerDb = new PackerDatabase(@"C:\Users\wben1\Downloads\userdb.txt");
//
// if (!packerDb.Load())
// {
//     Console.WriteLine("Failed to load packer database");
// }
//
// foreach (var packer in packerDb.GetSignatures())
// {
//     Console.WriteLine(packer.SignatureValues);
// }
//
// packerDb.GetSignatures()[0].SignatureValues.ToList().ForEach(x => Console.WriteLine("{0:X}", x));

// var regshot = new RegShot();
// RegistryKey snapshot_1 = regshot.TakeSnapshot();
// Console.WriteLine("Snapshot 1 taken");
//
// string empty = Console.ReadLine();
//
// RegistryKey snapshot_2 = regshot.TakeSnapshot();
// Console.WriteLine("Snapshot 2 taken");
//
// regshot.CompareSnapshots(snapshot_1, snapshot_2);

// var data = key.SubKeys["test"];
// foreach (var value in data.Values.Values)
// {
//     Console.WriteLine(value.Name);
//     Console.WriteLine(value.Data);
//     Console.WriteLine("");
// }    

Parser.Default.ParseArguments<Commands.PeInfo, Commands.PackerId, Commands.Hash>(args)
    .WithParsed<Commands.PeInfo>(PeInfoRun)
    .WithParsed<Commands.PackerId>(PackerIdRun)
    .WithParsed<Commands.Hash>(HashRun);

void PeInfoRun(Commands.PeInfo opts)
{
    var pe = new PE(opts.File);
    if (!pe.Load())
    {
        Console.WriteLine("Failed to load file");
        return;
    }

    PrintPe(pe);
}

void PackerIdRun(Commands.PackerId opts)
{
    var packerDb = new PackerDatabase(opts.Database);
    if (!packerDb.Load())
    {
        Console.WriteLine("Failed to load packer database");
    }

    var pe = new PE(opts.File);
    if (!pe.Load())
    {
        Console.WriteLine("Failed to load file");
        return;
    }

    PrintPe(pe);
    
    List<Signature> signatures = packerDb.ScanPE(pe, ScanMode.EpOnly);
    foreach (var signature in signatures)
    {
        Console.WriteLine(signature.Tool);
    }
}

void HashRun(Commands.Hash opts)
{
    var pe = new PE(opts.File);
    if (!pe.Load())
    {
        Console.WriteLine("Failed to load file");
        return;
    }

    IHasher hasher;
    switch (opts.Type)
    {
        case "sha256":
            hasher = new Sha256Hasher(pe);
            break;
        case "md5":
            hasher = new Md5Hasher(pe);
            break;
        default:
            Console.WriteLine("Unknown hash type");
            return;
    }
    
    Console.WriteLine(Convert.ToHexString(hasher.Hash()));
}


void PrintPe(PE pe)
{
    Console.WriteLine("Is DLL: {0}", pe.IsDLL());
    Console.WriteLine("Is 64 bit: {0}", pe.Is64Bit());

    Console.WriteLine("----DOS Headers----");
    Console.WriteLine("Magic: {0:X}", pe.DosHeaders.Magic);
    Console.WriteLine("Lfanew: {0:X}", pe.DosHeaders.Lfanew);

    Console.WriteLine("----NT Headers----");
    Console.WriteLine("Signature: {0:X}", pe.NtFileHeaders.Signature);
    Console.WriteLine("Machine: {0:X}", pe.NtFileHeaders.Machine);
    Console.WriteLine("NumberOfSections: {0:D}", pe.NtFileHeaders.NumberOfSections);
    Console.WriteLine("SizeOfOptionalHeader: {0:D}", pe.NtFileHeaders.SizeOfOptionalHeader);

    foreach (var section in pe.SectionHeaders)
    {
        Console.WriteLine("----Section----");
        Console.WriteLine("Name: {0}", section.Name);
        Console.WriteLine("VirtualSize: {0:D}", section.VirtualSize);
        Console.WriteLine("VirtualAddress: {0:X}", section.VirtualAddress);
        Console.WriteLine("SizeOfRawData: {0:D}", section.SizeOfRawData);
        Console.WriteLine("PointerToRawData: {0:X}", section.PointerToRawData);
    }
}
