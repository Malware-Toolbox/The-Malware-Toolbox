using MalwareToolbox.Library.VirusTotalAPI;
using MalwareToolbox.Library.DNSReqCapture;
using MalwareToolbox.LibraryC.Executables;
using MalwareToolbox.LibraryC.Hashing;
using MalwareToolbox.LibraryC.Unpackers;
using MalwareToolbox.LibraryC.RegShot;
using MalwareToolbox.LibraryC.Strings;
using static MalwareToolbox.ConsoleApp.BConsole.BConsole;
using static MalwareToolbox.ConsoleApp.Commands;
using static MalwareToolbox.ConsoleApp.PrettyPrint;

namespace MalwareToolbox.ConsoleApp;

public class Runners
{
    static void HashRun(Hash opts)
    {
        var file = new MalwareToolbox.LibraryC.Utils.File(opts.File);
        if (!file.Load())
        {
            Console.WriteLine("Failed to load file");
            return;
        }

        IHasher hasher;
        switch (opts.Type)
        {
            case "sha256":
                hasher = new Sha256Hasher(file);
                break;
            case "md5":
                hasher = new Md5Hasher(file);
                break;
            default:
                Console.WriteLine("Unknown hash type");
                return;
        }

        Console.WriteLine(Convert.ToHexString(hasher.Hash()));
    }

    static void PeInfoRun(Commands.PeInfo opts)
    {
        var file = new MalwareToolbox.LibraryC.Utils.File(opts.File);
        if (!file.Load())
        {
            Console.WriteLine("Failed to load file");
            return;
        }
        var pe = new PE(file);
        if (!pe.LoadHeaders())
        {
            Console.WriteLine("Failed to load PE");
            return;
        }

        PrintPe(pe);
    }

    static void PeidRun(Peid opts)
    {
        var packerDb = new PackerDatabase(opts.Database);
        if (!packerDb.Load())
        {
            Console.WriteLine("Failed to load packer database");
        }

        var file = new MalwareToolbox.LibraryC.Utils.File(opts.File);
        if (!file.Load())
        {
            Console.WriteLine("Failed to load file");
            return;
        }
        var pe = new PE(file);
        if (!pe.LoadHeaders())
        {
            Console.WriteLine("Failed to load PE");
            return;
        }

        // PrintPe(pe);

        List<Signature> signatures = packerDb.ScanPE(pe, ScanMode.EpOnly);
        foreach (var signature in signatures)
        {
            Console.WriteLine(signature.Tool);
        }
    }

    static void RegshotRun(Regshot opts)
    {
        var regshot = new RegShot();

        Console.WriteLine("Taking Snapshot 1...");
        RegistryHive snapshot_1 = regshot.TakeSnapshot(RegistryHiveType.HkeyCurrentUser);
        Console.WriteLine("Snapshot 1 taken");
        Console.WriteLine("");

        Console.WriteLine("Press any key to take snapshot 2...");
        Console.Read();

        Console.WriteLine("Taking Snapshot 2...");
        RegistryHive snapshot_2 = regshot.TakeSnapshot(RegistryHiveType.HkeyCurrentUser);
        Console.WriteLine("Snapshot 2 taken");
        Console.WriteLine("");

        var keysDiff = regshot.CompareSnapshots(snapshot_1, snapshot_2);

        Console.WriteLine("-------- Differences --------");

        foreach (var diff in keysDiff)
        {
            switch (diff.Type)
            {
                case DiffType.Added:
                    FgBlack(BgDarkGreen($" + [{diff.Key.FullPath}]", LF())).WriteLine();
                    break;
                case DiffType.Deleted:
                    BgDarkRed($" - [{diff.Key.FullPath}]", LF()).WriteLine();
                    break;
                case DiffType.Modified:
                    FgBlack(BgDarkYellow($" ~ [{diff.Key.FullPath}]")).WriteLine();
                    diff.ValuesDiff.ForEach(valueDiff =>
                     {
                         switch (valueDiff.Type)
                         {
                             case DiffType.Added:
                                 FgBlack(BgDarkGreen($" + [{valueDiff.New}]", LF())).WriteLine();
                                 break;
                             case DiffType.Deleted:
                                 BgDarkRed($" - [{valueDiff.Old}]", LF()).WriteLine();
                                 break;
                             case DiffType.Modified:
                                 FgBlack(
                                     "    ", 
                                     BgYellow(
                                         $" ~ {valueDiff.Old.Name}: ", 
                                         BgRed(valueDiff.Old), 
                                         " -> ", 
                                         BgGreen(valueDiff.New), 
                                         " ")
                                     ).WriteLine();
                                 break;
                         }
                     });
                    break;
            }
        }
    }

    static void StringsRun(Strings opts)
    {
        var file = new MalwareToolbox.LibraryC.Utils.File(opts.File);
        if (!file.Load())
        {
            Console.WriteLine("Failed to load file");
            return;
        }

        StringAnalyser strings = new StringAnalyser(file);
        List<String> result = strings.GenerateStrings(opts.Min, opts.Max);

        StringCategoriser categoriser = new StringCategoriser();
        var categoriseStrings = categoriser.CategoriseStrings(result);

        foreach (var categoryName in categoriseStrings.Keys)
        {
            Console.WriteLine(categoryName);
            foreach (var stringValue in categoriseStrings[categoryName])
            {
                Console.WriteLine($"    {stringValue}");
            }
        }
    }

    static void VirusTotalRun(VirusTotal opts)
    {
        var virusTotal = new VirusTotalAPI();
        Result? result = virusTotal.GetDetails(opts.ApiKey, opts.Hash);
        if (result == null)
        {
            Console.WriteLine("Failed to get details");
            return;
        }

        PrintVirusTotal(result);
    }

    static void DNSReqCaptureRun(DNSReqCapture opts)
    {
        // Make sure we revert dns if we force quit
        // Or not we will nuke our com's internet

        Console.CancelKeyPress += (sender, eventArgs) => {
            SetDNS.UnsetDNS();
        };

        SetDNS.SettingDNS("127.0.0.1");

        Console.WriteLine("Server Created");
        Server server = new Server();
        server.start();
        Console.WriteLine("Udp Listener started");

        try
        {
            while (true)
            {
                List<string> nameList = server.recv();
                Console.WriteLine(String.Join(".", nameList));

                Thread.Sleep(1000);
            }
        }

        catch (Exception e)
        {
            Console.WriteLine(e.Message);
            SetDNS.UnsetDNS();
        }

        SetDNS.UnsetDNS();
    }
}
